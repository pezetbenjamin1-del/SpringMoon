<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Jeu d'Esquive</title>
<style>
  body {
    background: #111;
    display: flex;
    justify-content: center;
    align-items: flex-start;
    height: 100vh;
    margin: 0;
    padding-top: 200px;
  }

  canvas {
    background: #222;
    border: 2px solid white;
  }

  /* Bouton Classement (droite) */
  #leaderboardBtn {
    position: absolute;
    top: 50%;
    right: 16px;
    transform: translateY(-50%);
    background: linear-gradient(135deg,#667eea 0%,#764ba2 100%);
    color: white;
    padding: 10px 14px;
    border-radius: 10px;
    text-decoration: none;
    font-weight: 700;
    box-shadow: 0 8px 24px rgba(0,0,0,0.35);
    z-index: 50;
  }
  #leaderboardBtn:hover { transform: translateY(-50%) translateY(-4px); }

  @media (max-width: 600px) {
    #leaderboardBtn { top: auto; bottom: 16px; right: 16px; transform: none; }
  }

  /* Taille r√©duite des boutons du s√©lecteur de cube */
  #selector button {
    padding: 8px 10px !important;
    font-size: 14px !important;
    margin: 5px !important;
    border-radius: 6px !important;
    min-width: 100px !important;
    max-width: 180px !important;
  }

  /* Style pour l'ic√¥ne (seulement) dans le bouton ‚Äî ne touche pas aux niveaux */
  #selector button > div:first-child .btnIcon {
    display: inline-block !important;
    width: auto !important;
    height: auto !important;
    vertical-align: middle !important;
    font-size: 20px !important;
    line-height: 1 !important;
    /* no stroke */
    text-shadow: none !important;
  }

  /* Barre de recharge du double saut */
  #rechargeBar {
    position: absolute;
    bottom: 10px;
    left: 10px;
    width: 200px;
    height: 20px;
    background-color: #444;
    border: 1px solid #fff;
  }

  #rechargeBarFilled {
    height: 100%;
    background-color: #0f0; /* Couleur de la barre de recharge */
  }

  /* Affichage du meilleur rang dans le coin bas √† droite */
  #bestRank {
    position: absolute;
    bottom: 10px;
    right: 10px;
    color: white;
    font-size: 16px;
    font-family: Arial, sans-serif;
  }

  /* Bouton pouvoir mobile */
  #powerBtn {
    position: absolute;
    bottom: 20px;
    right: 20px;
    width: 60px;
    height: 60px;
    border-radius: 50%;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border: none;
    font-size: 28px;
    cursor: pointer;
    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
    display: none;
    z-index: 40;
  }

  #powerBtn:active {
    transform: scale(0.95);
  }

  @media (max-width: 768px) {
    #powerBtn {
      display: block;
    }
  }

  /* Affichage DOM du score en direct */
  #liveScore {
    position: absolute;
    top: 10px;
    right: 10px;
    color: white;
    font-size: 18px;
    font-family: Arial, sans-serif;
    background: rgba(0,0,0,0.3);
    padding: 6px 10px;
    border-radius: 8px;
    z-index: 60;
  }
  #powerCooldown {
    position: absolute;
    top: 42px;
    right: 10px;
    color: white;
    font-size: 14px;
    font-family: Arial, sans-serif;
    background: rgba(0,0,0,0.25);
    padding: 4px 8px;
    border-radius: 6px;
    z-index: 60;
  }
</style>
</head>
<body>

<div id="gameWrap" style="position:relative;display:inline-block;">
  <canvas id="game" width="600" height="300"></canvas>
  <div id="brilliantInfo" style="position:absolute;left:50%;transform:translateX(-50%);top:calc(100% + 8px);width:600px;text-align:center;color:#ccc;font-size:14px;">
    La cat√©gorie ¬´ Brillant ¬ª poss√®de un pouvoir automatique de r√©flexion (15s cooldown).
  </div>
</div>
<div id="rechargeBar"><div id="rechargeBarFilled"></div></div>
<div id="bestRank"></div>
<div id="liveScore"></div>
<div id="powerCooldown"></div>
<button id="powerBtn" onclick="activateAbility()">‚ö°</button>

<!-- Bouton acc√®s classement (ouvre le fichier local dans un nouvel onglet) -->
<a id="leaderboardBtn" href="leaderboard.html" target="_blank" rel="noopener noreferrer" title="Voir le classement">üèÜ Classement</a>

<!-- S√©lecteur de cube -->
<div id="selector" style="position:absolute;top:20px;left:50%;transform:translateX(-50%);z-index:10;text-align:center;width:90%;display:flex;flex-direction:column;align-items:center;">
  <div style="margin-bottom:10px;font-size:18px;color:#fff;font-weight:bold;">Choisis un cube :</div>
  <div style="display:flex;flex-direction:column;align-items:center;gap:8px;">
    <div style="color:#fff;font-size:14px;">
      <label for="selectorMode" style="margin-right:8px;font-weight:600;color:#fff;">Mode :</label>
      <select id="selectorMode" onchange="changeSelectorMode(this.value)" style="padding:6px;border-radius:6px;border:1px solid #444;background:#222;color:#fff;">
        <option value="classique" selected>Classique (10 cubes)</option>
        <option value="brillant">Brillant (2 cubes)</option>
      </select>
    </div>

    <div id="classicGrid" style="display:grid;grid-template-columns:repeat(10,129px);gap:6px;justify-content:center;max-width:1220px;">
      <button id="redBtn" onclick="selectType('red')" style="background:red;color:#fff;border:none;padding:10px 14px;font-size:16px;margin:5px;border-radius:8px;"><div><span class="btnIcon">üî¥</span> Rouge</div><div style="font-size:12px;margin-top:5px;">Meilleur : Niveau <span id="redLevel">1</span></div></button>
      <button id="blueBtn" onclick="selectType('blue')" style="background:blue;color:#fff;border:none;padding:10px 14px;font-size:16px;margin:5px;border-radius:8px;"><div><span class="btnIcon">üîµ</span> Bleu</div><div style="font-size:12px;margin-top:5px;">Meilleur : Niveau <span id="blueLevel">1</span></div></button>
      <button id="greenBtn" onclick="selectType('green')" style="background:green;color:#fff;border:none;padding:10px 14px;font-size:16px;margin:5px;border-radius:8px;"><div><span class="btnIcon">üü¢</span> Vert</div><div style="font-size:12px;margin-top:5px;">Meilleur : Niveau <span id="greenLevel">1</span></div></button>
      <button id="yellowBtn" onclick="selectType('yellow')" style="background:gold;color:#000;border:none;padding:10px 14px;font-size:16px;margin:5px;border-radius:8px;"><div><span class="btnIcon">üü°</span> Jaune</div><div style="font-size:12px;margin-top:5px;">Meilleur : Niveau <span id="yellowLevel">1</span></div></button>
      <button id="purpleBtn" onclick="selectType('purple')" style="background:purple;color:#fff;border:none;padding:10px 14px;font-size:16px;margin:5px;border-radius:8px;"><div><span class="btnIcon">üü£</span> Violet</div><div style="font-size:12px;margin-top:5px;">Meilleur : Niveau <span id="purpleLevel">1</span></div></button>
      <button id="orangeBtn" onclick="selectType('orange')" style="background:orange;color:#000;border:none;padding:10px 14px;font-size:16px;margin:5px;border-radius:8px;"><div><span class="btnIcon">üü†</span> Orange</div><div style="font-size:12px;margin-top:5px;">Meilleur : Niveau <span id="orangeLevel">1</span></div></button>
      <button id="cyanBtn" onclick="selectType('cyan')" style="background:cyan;color:#000;border:none;padding:10px 14px;font-size:16px;margin:5px;border-radius:8px;"><div><span style="display:inline-block;width:18px;height:18px;border-radius:50%;background:cyan;border:1px solid #000;vertical-align:middle;margin-right:8px;"></span> Cyan</div><div style="font-size:12px;margin-top:5px;">Meilleur : Niveau <span id="cyanLevel">1</span></div></button>
      <button id="grayBtn" onclick="selectType('gray')" style="background:gray;color:#fff;border:none;padding:10px 14px;font-size:16px;margin:5px;border-radius:8px;"><div style="display:flex;align-items:center;gap:6px;"><span style="display:inline-block;width:18px;height:18px;border-radius:50%;background:gray;border:1px solid #000;vertical-align:middle;margin-left:23px;"></span> Gris</div><div style="font-size:12px;margin-top:5px;">Meilleur : Niveau <span id="grayLevel">1</span></div></button>
      <button id="pinkBtn" onclick="selectType('pink')" style="background:#FF69B4;color:#fff;border:none;padding:10px 14px;font-size:16px;margin:5px;border-radius:8px;"><div><span class="btnIcon">üíó</span> Rose</div><div style="font-size:12px;margin-top:5px;">Meilleur : Niveau <span id="pinkLevel">1</span></div></button>
      <button id="brownBtn" onclick="selectType('brown')" style="background:#440E03;color:#fff;border:none;padding:10px 14px;font-size:16px;margin:5px;border-radius:8px;"><div style="display:flex;align-items:center;gap:6px;"><span style="display:inline-block;width:18px;height:18px;border-radius:50%;background:brown;border:1px solid #000;vertical-align:middle;margin-left:23px;"></span> Marron</div><div style="font-size:12px;margin-top:5px;">Meilleur : Niveau <span id="brownLevel">1</span></div></button>
    </div>

    <div id="brilliantGrid" style="display:none;max-width:1220px;">
      <div style="display:grid;grid-template-columns:repeat(10,120px);gap:6px;justify-content:center;">
        <button id="rubisBtn" onclick="selectType('rubis')" style="background:linear-gradient(135deg,#ff5f5f 0%,#ff1f1f 100%);color:#fff;border:none;padding:10px 14px;font-size:16px;margin:5px;border-radius:8px;box-shadow:0 6px 18px rgba(255,0,0,0.12);">
          <div><span class="btnIcon">üíé</span> Rubis</div>
          <div style="font-size:12px;margin-top:5px;">Meilleur : Niveau <span id="rubisLevel">1</span></div>
        </button>
        <button id="saphirBtn" onclick="selectType('saphir')" style="background:linear-gradient(135deg,#4aa0ff 0%,#1f6fff 100%);color:#fff;border:none;padding:10px 14px;font-size:16px;margin:5px;border-radius:8px;box-shadow:0 6px 18px rgba(30,120,255,0.12);">
          <div><span class="btnIcon">üíé</span> Saphir</div>
          <div style="font-size:12px;margin-top:5px;">Meilleur : Niveau <span id="saphirLevel">1</span></div>
        </button>
      </div>
    </div>
  </div>
</div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

// ====== JOUEUR ======
let player = {
  x: canvas.width / 2 - 15,
  y: 220,
  width: 30,
  height: 30,
  velocityY: 0,
  jumping: false,
  doubleJumpUsed: false // Flag pour savoir si le double saut a √©t√© utilis√©
};

let gravity = 0.8;
let obstacles = [];
let gameOver = false;

// ====== SCORE ======
// Scores par cube (individuels)
  let scores = { red: 0, blue: 0, green: 0, yellow: 0, purple: 0, orange: 0, cyan: 0, gray: 0, pink: 0, brown: 0, rubis: 0, saphir: 0 }; // Scores par cube (individuels)
let bestScore = localStorage.getItem("bestScore") || 0;

// Meilleurs scores pour chaque cube
let bestScores = {
  red: localStorage.getItem("bestScore_red") || 0,
  blue: localStorage.getItem("bestScore_blue") || 0,
  green: localStorage.getItem("bestScore_green") || 0,
  yellow: localStorage.getItem("bestScore_yellow") || 0,
  purple: localStorage.getItem("bestScore_purple") || 0,
  orange: localStorage.getItem("bestScore_orange") || 0,
  cyan: localStorage.getItem("bestScore_cyan") || 0,
  gray: localStorage.getItem("bestScore_gray") || 0,
  pink: localStorage.getItem("bestScore_pink") || 0
  ,brown: localStorage.getItem("bestScore_brown") || 0
  ,rubis: localStorage.getItem("bestScore_rubis") || 0
  ,saphir: localStorage.getItem("bestScore_saphir") || 0
};



// ====== DIFFICULT√â ======
let obstacleSpeed = 6;
let spawnRate = 1500; // Spawn des obstacles toutes les 1,5 secondes initialement
// Bonus : appliquer une seule fois un petit boost de vitesse √† 100000 pts
let bonusSpeed100kApplied = false;

// ====== BOUCLIER / INVINCIBILIT√â (BLEU) ======
let shieldActive = false; // Invincibilit√© en cours
let shieldReady = true; // Le bouclier est pr√™t √† √™tre utilis√©
let shieldDuration = 2000; // Dur√©e du bouclier en ms (2 secondes)
let shieldCooldown = 10000; // Cooldown en ms (10 secondes)
let lastShieldTime = 0; // Moment o√π le bouclier s'est termin√© (d√©but du cooldown)
let shieldStartTime = 0; // Moment d'activation du bouclier
let rechargeProgress = 1; // La barre est pleine au d√©but (valeur entre 0 et 1)

// ====== SAPHIR (Brillant) : bouclier similaire au bleu mais cooldown 15s ======
let saphirShieldActive = false;
let saphirShieldReady = true;
let saphirShieldDuration = 2000; // m√™mes 2s de dur√©e
let saphirShieldCooldown = 15000; // 15s cooldown
let lastSaphirShieldTime = 0;
let saphirShieldStartTime = 0;

// ====== VOL (VERT) ======
let flyActive = false;
let flyReady = true;
let flyDuration = 2000; // 2s
let flyCooldown = 9000; // 9s
let lastFlyTime = 0;
let flyStartTime = 0;
let flyFalling = false; // Invincibilit√© pendant la descente apr√®s le vol

// ====== RALENTISSEMENT (VIOLET) ======
let slowmoActive = false;
let slowmoReady = true;
let slowmoDuration = 3000; // 3s
let slowmoCooldown = 14000; // 14s
let lastSlowmoTime = 0;
let slowmoStartTime = 0;
let slowmoMultiplier = 0.5; // Ralentir √† 50% de la vitesse

// ====== AGILIT√â ACCRUE (ORANGE) ======
let agilityActive = false;
let agilityReady = true;
let agilityDuration = 3000; // 3s
let agilityCooldown = 10000; // 10s
let lastAgilityTime = 0;
let agilityStartTime = 0;
let agilityVelocityBoost = 1.3; // Augmente la v√©locit√© du saut de 30% (plus rapide mais meme hauteur)

// ====== TIR (ROUGE) ======
let redInterval = null;
let lastRedShot = 1;
let redCooldown = 5000; // 5s
// Cooldown sp√©cifique pour le tir du Rubis
let rubisShotCooldown = 10000; // 10s

// ====== MULTIPLICATEUR DE SCORE (JAUNE) ======
let scoreMultiplierActive = false;
let scoreMultiplierReady = true;
let scoreMultiplierDuration = 3000; // 3s
let scoreMultiplierCooldown = 12000; // 12s
let lastScoreMultiplierTime = 0;
let scoreMultiplierStartTime = 0;
let scoreMultiplier = 1; // Multiplicateur du score (1 = normal, 3 = triple gain)

// ====== AIMANT D'OBSTACLES (CYAN) ======
let magnetActive = false;
let magnetReady = true;
let magnetDuration = 2000; // 2s
let magnetCooldown = 10000; // 10s
let lastMagnetTime = 0;
let magnetStartTime = 0;

// ====== R√âDUCTION D'OBSTACLES (GRIS) ======
let shrinkActive = false;
let shrinkReady = true;
let shrinkDuration = 4000; // 4s
let shrinkCooldown = 13000; // 13s
let lastShrinkTime = 0;
let shrinkStartTime = 0;
let shrinkFactor = 0.5; // obstacles rendered at 50% size when active

// ====== ARR√äT DU TEMPS (ROSE) ======
let timeStopActive = false;
let timeStopReady = true;
let timeStopDuration = 3000; // 3s
let timeStopCooldown = 15000; // 15s
let lastTimeStopTime = 0;
let timeStopStartTime = 0;
let timeStopJustEnded = false; // D√©lai d'1 seconde apr√®s la fin pour pas de g√©n√©ration imm√©diate

// ====== SECONDE VIE (MARRON) ======
let brownSecondLifeAvailable = true; // Poss√®de une seconde vie au d√©but de la partie
let brownInvincible = false; // Invincibilit√© courte apr√®s utilisation
let brownInvincibleDuration = 3000; // 3s d'invincibilit√© apr√®s utilisation
let brownCooldown = 33000; // 33s de cooldown
let lastBrownUse = 0;
let brownReady = true;
let brownInvincibleStart = 0;
let brownInvincibleEnd = 0;

// ====== BRILLANT : r√©flexions s√©par√©es pour Rubis et Saphir ======
let reflectReadyRubis = true;
let reflectCooldownRubis = 15000; // 15s
let lastReflectTimeRubis = 0;

let reflectReadySaphir = true;
let reflectCooldownSaphir = 15000; // 15s
let lastReflectTimeSaphir = 0;

// ====== COURONNES POUR LES NIVEAUX ======
let currentLevels = { red: 1, blue: 1, green: 1, yellow: 1, purple: 1, orange: 1, cyan: 1, gray: 1, pink: 1, brown: 1 };
let levelUpFlags = { red: false, blue: false, green: false, yellow: false, purple: false, orange: false, cyan: false, gray: false, pink: false, brown: false };
// Ajouter rubis aux niveaux
currentLevels.rubis = 1;
levelUpFlags.rubis = false;
// Ajouter saphir aux niveaux
currentLevels.saphir = 1;
levelUpFlags.saphir = false;

// ====== NIVEAUX PAR CUBE ======
// Chaque palier de 1000 points augmente d'1 niveau, niveaux 1..100
function getLevelFromScore(s) {
  return Math.min(100, Math.floor(s / 1000) + 1);
}

// ====== SAUT (CLIC / TAP / ESPACE) ======
function jump() {
  if (!player.jumping) {
    // Premier saut
    let jumpForce = -15;
    // Agilit√© accrue : saute plus rapidement (v√©locit√© augment√©e)
    if (player.type === 'orange' && agilityActive) {
      jumpForce *= agilityVelocityBoost;
    }
    // Violet (ralentissement) : saute moins haut quand le pouvoir est actif
    if (player.type === 'purple' && slowmoActive) {
      jumpForce *= 0.7; // Saute √† 70% de la hauteur normale
    }
    player.velocityY = jumpForce;
    player.jumping = true;
    // R√©initialise les flags li√©s au bouclier si besoin
  }
  // Note: Le pouvoir n'est activ√© que via clic droit ou le bouton mobile, pas avec le clic gauche
}

// Ajouter espace pour sauter
document.addEventListener('keydown', function(e) {
  if (e.key === ' ' || e.code === 'Space') {
    e.preventDefault();
    jump();
  }
});

// Saut n'importe o√π sur l'√©cran avec clic gauche ou touch (sauf sur les boutons de s√©lection)
document.addEventListener("mousedown", function(e) {
  // Ignorer les clics sur les boutons
  if (e.target.tagName === 'BUTTON' || e.target.closest('button')) return;
  if (e.button === 0) jump();
});
document.addEventListener("touchstart", function(e) {
  // Ignorer les touches sur les boutons
  if (e.target.tagName === 'BUTTON' || e.target.closest('button')) return;
  e.preventDefault();
  jump();
}, { passive: false });

// Activer le pouvoir avec le clic droit n'importe o√π sur l'√©cran (sauf sur les boutons de s√©lection)
document.addEventListener('contextmenu', function(e) {
  // Ignorer les clics droit sur les boutons
  if (e.target.tagName === 'BUTTON' || e.target.closest('button')) return;
  e.preventDefault();
  activateAbility();
});

// Activer le bouclier d'invincibilit√©
// Activer le pouvoir en fonction du type s√©lectionn√©
function activateAbility() {
  if (!player.type) return;
  if (player.type === 'blue') {
    if (!shieldReady || shieldActive) return;
    shieldActive = true;
    shieldReady = false;
    shieldStartTime = Date.now();
    setTimeout(function() {
      shieldActive = false;
      lastShieldTime = Date.now();
    }, shieldDuration);
  } else if (player.type === 'green') {
    if (!flyReady || flyActive) return;
    flyActive = true;
    flyReady = false;
    flyStartTime = Date.now();
    // D√©sactiver la gravit√© pendant la dur√©e
    setTimeout(function() {
      flyActive = false;
      // Activer une courte invincibilit√© pendant la descente
      flyFalling = true;

      // Mettre √† jour l'affichage DOM du score en direct
      try {
        const liveEl = document.getElementById('liveScore');
        if (liveEl) {
          if (player.type) {
            const labels = {
              red: 'üî¥ Rouge', blue: 'üîµ Bleu', green: 'üü¢ Vert', cyan: '‚ìÇÔ∏è Cyan', yellow: 'üü° Jaune',
              purple: 'üü£ Violet', orange: 'üü† Orange', gray: 'üîò Gris', pink: 'üíó Rose', brown: 'üü´ Marron', rubis: '<span class="btnIcon">üíé</span> Rubis'
            };
            liveEl.innerHTML = labels[player.type] + ' : ' + scores[player.type];
          } else {
            liveEl.innerHTML = 'Score : 0';
          }
        }
      } catch (e) { /* silent */ }
      lastFlyTime = Date.now();
    }, flyDuration);
  } else if (player.type === 'yellow') {
    if (!scoreMultiplierReady || scoreMultiplierActive) return;
    scoreMultiplierActive = true;
    scoreMultiplierReady = false;
    scoreMultiplierStartTime = Date.now();
    scoreMultiplier = 3; // Triple le gain de score
    setTimeout(function() {
      scoreMultiplierActive = false;
      scoreMultiplier = 1;
      lastScoreMultiplierTime = Date.now();
    }, scoreMultiplierDuration);
  } else if (player.type === 'purple') {
    if (!slowmoReady || slowmoActive) return;
    slowmoActive = true;
    slowmoReady = false;
    slowmoStartTime = Date.now();
    setTimeout(function() {
      slowmoActive = false;
      lastSlowmoTime = Date.now();
    }, slowmoDuration);
  } else if (player.type === 'orange') {
    if (!agilityReady || agilityActive) return;
    agilityActive = true;
    agilityReady = false;
    agilityStartTime = Date.now();
    setTimeout(function() {
      agilityActive = false;
      lastAgilityTime = Date.now();
    }, agilityDuration);
  } else if (player.type === 'gray') {
    if (!shrinkReady || shrinkActive) return;
    shrinkActive = true;
    shrinkReady = false;
    shrinkStartTime = Date.now();
    // Fin automatique du pouvoir gris
    setTimeout(function() {
      shrinkActive = false;
      lastShrinkTime = Date.now();
    }, shrinkDuration);
  } else if (player.type === 'brown') {
    // Le pouvoir marron (seconde vie) est d√©clench√© automatiquement lors d'une collision fatale,
    // il n'a pas d'activation manuelle ici. Ignorer l'appel.
    return;
  } else if (player.type === 'cyan') {
    if (!magnetReady || magnetActive) return;
    magnetActive = true;
    magnetReady = false;
    magnetStartTime = Date.now();
    setTimeout(function() {
      magnetActive = false;
      lastMagnetTime = Date.now();
    }, magnetDuration);
  } else if (player.type === 'red' || player.type === 'rubis') {
    // Tir manuel pour le rouge et rubis
    const now = Date.now();
    const shotCooldownNow = player.type === 'rubis' ? rubisShotCooldown : redCooldown;
    if (now - lastRedShot >= shotCooldownNow) {
      autoShoot();
      lastRedShot = now;
    }
  } else if (player.type === 'pink') {
    if (!timeStopReady || timeStopActive) return;
    timeStopActive = true;
    timeStopReady = false;
    timeStopStartTime = Date.now();
    setTimeout(function() {
      timeStopActive = false;
      timeStopJustEnded = true; // Emp√™cher la g√©n√©ration imm√©diate pendant 1s
      lastTimeStopTime = Date.now();
      // Apr√®s 1 seconde, autoriser la g√©n√©ration √† nouveau
      setTimeout(function() {
        timeStopJustEnded = false;
      }, 1000);
    }, timeStopDuration);
  } else if (player.type === 'saphir') {
    // Pouvoir du Saphir : bouclier (comme le bleu) ‚Äî cooldown 15s
    if (!saphirShieldReady || saphirShieldActive) return;
    saphirShieldActive = true;
    saphirShieldReady = false;
    saphirShieldStartTime = Date.now();
    setTimeout(function() {
      saphirShieldActive = false;
      lastSaphirShieldTime = Date.now();
    }, saphirShieldDuration);
  }
}

// ====== OBSTACLES ======
function createObstacle() {
  // Ne pas cr√©er d'obstacles tant que le joueur n'a pas choisi son cube
  if (!player.type) return false;

  let side = Math.random() < 0.5 ? "left" : "right";
  obstacles.push({
    x: side === "left" ? -30 : canvas.width,
    y: 220,
    width: 30,
    height: 30,
    speed: side === "left" ? obstacleSpeed : -obstacleSpeed
  });
  return true;
}

// S√©lectionner le type de joueur
function selectType(t) {
  player.type = t;
  // Mettre √† jour l'emoji du bouton pouvoir
  updatePowerButton();
  // Verrouiller le choix : d√©sactiver tous les boutons du s√©lecteur
  const btns = document.querySelectorAll('#selector button');
  btns.forEach(b => {
    b.disabled = true;
    b.style.opacity = '0.5';
    b.style.cursor = 'not-allowed';
  });
  // Nettoyer √©tat pr√©c√©dent
  if (redInterval) { clearInterval(redInterval); redInterval = null; }

  if (t === 'red') {
    // Passage en mode rouge : tir MANUEL. rendre le tir imm√©diatement pr√™t
    lastRedShot = Date.now() - redCooldown;
  } else if (t === 'blue') {
    // r√©initialiser bouclier
    shieldActive = false; shieldReady = true; lastShieldTime = 0;
  } else if (t === 'green') {
    flyActive = false; flyReady = true; lastFlyTime = 0;
  } else if (t === 'yellow') {
    // r√©initialiser multiplicateur de score
    scoreMultiplierActive = false; scoreMultiplierReady = true; lastScoreMultiplierTime = 0; scoreMultiplier = 1;
  } else if (t === 'purple') {
    // r√©initialiser ralentissement
    slowmoActive = false; slowmoReady = true; lastSlowmoTime = 0;
  } else if (t === 'orange') {
    // r√©initialiser agilit√©
    agilityActive = false; agilityReady = true; lastAgilityTime = 0;
  } else if (t === 'cyan') {
    // r√©initialiser aimant
    magnetActive = false; magnetReady = true; lastMagnetTime = 0;
  } else if (t === 'gray') {
    // r√©initialiser r√©duction
    shrinkActive = false; shrinkReady = true; lastShrinkTime = 0;
  } else if (t === 'brown') {
    // r√©initialiser seconde vie marron
    brownSecondLifeAvailable = true; brownInvincible = false; brownReady = true; lastBrownUse = 0;
  } else if (t === 'rubis') {
    // rubis : comportement de tir comme le rouge (cooldown sp√©cifique) + r√©flexion pr√™te
    lastRedShot = Date.now() - rubisShotCooldown;
    reflectReadyRubis = true; lastReflectTimeRubis = 0;
  } else if (t === 'saphir') {
    // saphir : bouclier (comme bleu) + r√©flexion pr√™te sp√©cifique
    saphirShieldActive = false; saphirShieldReady = true; lastSaphirShieldTime = 0;
    reflectReadySaphir = true; lastReflectTimeSaphir = 0;
  } else if (t === 'pink') {
    // r√©initialiser arr√™t du temps
    timeStopActive = false; timeStopReady = true; lastTimeStopTime = 0;
  }
}

// Mettre √† jour l'emoji du bouton pouvoir selon le type de cube
function updatePowerButton() {
  const powerBtn = document.getElementById('powerBtn');
  const emojis = {
    red: 'üî´',
    blue: 'üõ°Ô∏è',
    green: 'üïäÔ∏è',
    yellow: '‚ö°x3',
    purple: '‚è±',
    orange: '‚ö°',
    cyan: 'üß≤',
    gray: '‚á≥',
    pink: '‚è±',
    brown: '<span class="btnIcon">üíï</span>',
    rubis: '<span class="btnIcon">üíé</span>',
    saphir: '<span class="btnIcon">üíé</span>'
  };
  powerBtn.innerHTML = emojis[player.type] || '‚ö°';
}

// Mettre √† jour l'affichage des meilleurs niveaux
function updateBestLevelsDisplay() {
  // Mettre √† jour les niveaux et d√©tecter les level-ups
  ['red', 'blue', 'green', 'cyan', 'yellow', 'purple', 'orange', 'gray', 'brown', 'pink', 'rubis', 'saphir'].forEach(color => {
    const newLevel = getLevelFromScore(bestScores[color]);
    const levelElement = document.getElementById(color + 'Level');
    
    if (newLevel > currentLevels[color]) {
      // Level up !
      currentLevels[color] = newLevel;
      levelUpFlags[color] = true;
      levelElement.textContent = newLevel + " üëë";
    } else {
      levelElement.textContent = newLevel;
    }
  });
}

// Tir automatique pour le cube rouge : neutralise le bloc le plus proche devant le joueur
function autoShoot() {
  if (obstacles.length === 0) return;
  // Si une cible pr√©-s√©lectionn√©e existe (markedTargetBy), l'utiliser
  let obs = obstacles.find(o => o.markedTargetBy);
  if (!obs) {
    // Sinon, trouver l'obstacle le plus proche horizontalement
    let bestIndex = -1;
    let bestDist = Infinity;
    for (let i = 0; i < obstacles.length; i++) {
      const o = obstacles[i];
      const dx = Math.abs((o.x + o.width/2) - (player.x + player.width/2));
      const dy = Math.abs((o.y + o.height/2) - (player.y + player.height/2));
      if (dx < 200 && dy < 50 && dx < bestDist) { bestDist = dx; bestIndex = i; }
    }
    if (bestIndex !== -1) obs = obstacles[bestIndex];
  }

  if (obs) {
    // Suppression imm√©diate sans animation
    try {
      if (player && player.type && scores[player.type] !== undefined) scores[player.type] += 100;
      else scores['red'] += 100;
    } catch (e) { scores['red'] += 100; }
    const idx = obstacles.indexOf(obs);
    if (idx !== -1) obstacles.splice(idx, 1);
  }
}

// ====== BOUCLE DE JEU ======
let gameStartTime = Date.now(); // Enregistrer le moment o√π le jeu commence

let lastObstacleTime = 0;
let obstacleInterval = setInterval(() => {
  let now = Date.now();
  // Ne pas g√©n√©rer d'obstacles si le temps est arr√™t√© (rose) ou vient juste de s'arr√™ter
  if (timeStopActive || timeStopJustEnded) return;
  // Ralentir le spawnRate si le violet est actif
  let effectiveSpawnRate = slowmoActive ? spawnRate / slowmoMultiplier : spawnRate;
  if (now - lastObstacleTime >= effectiveSpawnRate) {
    const created = createObstacle();
    if (created) lastObstacleTime = now;
  }
}, 100); // V√©rifie chaque 100ms pour √©viter les regroupements

// R√©duit progressivement le spawnRate toutes les 10 secondes
setInterval(() => {
  let elapsedTime = Date.now() - gameStartTime; // Temps √©coul√© depuis le d√©but du jeu

  if (elapsedTime >= 10000) { // Si plus de 10 secondes se sont √©coul√©es
    // R√©tablir comportement d'origine : progression standard pour tous les cubes
    const decrease = 100; // ms de r√©duction toutes les 10s
    const speedInc = 0.2; // vitesse ajout√©e toutes les 10s
    const minSpawn = 700; // limite inf√©rieure
    spawnRate = Math.max(minSpawn, spawnRate - decrease);
    obstacleSpeed += speedInc;

    // Le spawnRate est mis √† jour, le nouvel intervalle s'applique automatiquement

    // R√©initialiser le moment de r√©f√©rence pour la prochaine r√©duction
    gameStartTime = Date.now();
  }
}, 10000); // V√©rifie toutes les 10 secondes (10000 ms)

// ====== FONCTION DE RANG ======
function getRank(score) {
  if (score < 2000) return "D√©butant";
  if (score < 5000) return "Novice";
  if (score < 10000) return "Interm√©diaire";
  if (score < 20000) return "Avanc√©";
  if (score < 50000) return "Expert";
  if (score >= 50000) return "Ma√Ætre";
}

// ====== SOUMETTRE UN SCORE ======
async function submitScore(playerName, score, cubeType) {
  try {
    const response = await fetch('http://localhost:3000/api/score', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        playerName: playerName,
        score: score,
        type: cubeType
      })
    });

    if (response.ok) {
      const data = await response.json();
      alert('‚úÖ ' + data.message + '\n\nüëâ Voir le classement: http://localhost:3000/leaderboard');
      return true;
    } else {
      alert('‚ùå Erreur lors de l\'enregistrement du score');
      return false;
    }
  } catch (error) {
    console.error('Error:', error);
    // Fallback: stocker en localStorage si le serveur ne r√©pond pas
    let leaderboard = JSON.parse(localStorage.getItem('leaderboard') || '[]');
    leaderboard.push({
      playerName: playerName.substring(0, 50),
      score: parseInt(score),
      type: cubeType,
      timestamp: new Date().toISOString()
    });
    localStorage.setItem('leaderboard', JSON.stringify(leaderboard));
    alert('‚úÖ Score enregistr√© localement!\n(Le serveur ne r√©pond pas)');
    return true;
  }
}

// ====== GAME OVER ======
function gameOverScreen() {
  if (scores[player.type] > bestScores[player.type]) {
    bestScores[player.type] = scores[player.type];
    localStorage.setItem("bestScore_" + player.type, bestScores[player.type]);
  }
  
  if (scores[player.type] > bestScore) {
    bestScore = scores[player.type];
    localStorage.setItem("bestScore", bestScore);
  }
  
  let rank = getRank(scores[player.type]);
  
  alert(
    "üíÄ GAME OVER\n" +
    "Score : " + scores[player.type] + "\n" +
    "Meilleur score cube : " + bestScores[player.type] + "\n" +
    "Meilleur score global : " + bestScore + "\n" +
    "Rang atteint : " + rank + "\n\n" +
    "Meilleurs niveaux par cube :\n" +
    "üî¥ Rouge : " + getLevelFromScore(bestScores.red) + "\n" +
    "üîµ Bleu : " + getLevelFromScore(bestScores.blue) + "\n" +
    "üü¢ Vert : " + getLevelFromScore(bestScores.green) + "\n" +
    "üî∑ Cyan : " + getLevelFromScore(bestScores.cyan) + "\n" +
    "üü° Jaune : " + getLevelFromScore(bestScores.yellow) + "\n" +
    "üü£ Violet : " + getLevelFromScore(bestScores.purple) + "\n" +
    "üü† Orange : " + getLevelFromScore(bestScores.orange) + "\n" +
    "üîò Gris : " + getLevelFromScore(bestScores.gray) + "\n" +
    "üíó Rose : " + getLevelFromScore(bestScores.pink)
  );

  // Proposer de soumettre le score
  const submitConfirm = confirm("üìä Voulez-vous soumettre votre score au classement mondial?");
  if (submitConfirm) {
    const playerName = prompt("Quel est votre pseudo? (max 50 caract√®res)", "Joueur");
    if (playerName && playerName.trim()) {
      submitScore(playerName.trim(), scores[player.type], player.type);
    }
  }

  location.reload();
}

// ====== BOUCLE DE JEU ======
function update() {
  if (gameOver) return;

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Score (n'augmente que si le joueur a choisi un cube)
  if (player.type) scores[player.type] += 5 * scoreMultiplier;
  const totalScore = scores.red + scores.blue + scores.green + scores.yellow + scores.purple + scores.orange + scores.cyan + scores.gray + scores.pink + scores.brown + scores.rubis + scores.saphir;
  // √Ä 100000 points : appliquer une seule fois +0.1 √† la vitesse des obstacles
  if (!bonusSpeed100kApplied && totalScore >= 100000) {
    obstacleSpeed += 0.1;
    bonusSpeed100kApplied = true;
  }

  // Pr√©-s√©lection visuelle de la cible pour Rouge / Rubis quand le tir est pr√™t
  try {
    // Clear previous marks
    obstacles.forEach(o => { delete o.markedTargetBy; });
    if (player && (player.type === 'red' || player.type === 'rubis')) {
      const nowt = Date.now();
      const currentShotCooldown = player.type === 'rubis' ? rubisShotCooldown : redCooldown;
      if (nowt - lastRedShot >= currentShotCooldown) {
        // trouver la cible la plus proche
        let bestIndex = -1;
        let bestDist = Infinity;
        for (let i = 0; i < obstacles.length; i++) {
          const obs = obstacles[i];
          const dx = Math.abs((obs.x + obs.width/2) - (player.x + player.width/2));
          const dy = Math.abs((obs.y + obs.height/2) - (player.y + player.height/2));
          if (dx < 200 && dy < 50 && dx < bestDist) { bestDist = dx; bestIndex = i; }
        }
        if (bestIndex !== -1) {
          // marquer par type exact (red, rubis, saphir)
          obstacles[bestIndex].markedTargetBy = player.type;
        }
      }
    }
  } catch (e) { /* silent */ }
  
  // Mettre √† jour l'affichage des couronnes en temps r√©el
  updateBestLevelsDisplay();

  ctx.fillStyle = "white";
  ctx.font = "16px Arial";
  ctx.fillText("Meilleur score : " + bestScore, 10, 20);
  ctx.fillText("Niveaux R/B/V/BL/J/P/O/G/Ro/Ru : " + getLevelFromScore(scores.red) + " / " + getLevelFromScore(scores.blue) + " / " + getLevelFromScore(scores.green) + " / " + getLevelFromScore(scores.cyan) + " / " + getLevelFromScore(scores.yellow) + " / " + getLevelFromScore(scores.purple) + " / " + getLevelFromScore(scores.orange) + " / " + getLevelFromScore(scores.gray) + " / " + getLevelFromScore(scores.pink) + " / " + getLevelFromScore(scores.rubis), 10, 40);
  
  // Afficher le score du cube s√©lectionn√©
  if (player.type === 'red') {
    ctx.fillStyle = "red";
    ctx.fillText("üî¥ Rouge : " + scores.red, 10, 60);
  } else if (player.type === 'blue') {
    ctx.fillStyle = "lightblue";
    ctx.fillText("üîµ Bleu : " + scores.blue, 10, 60);
  } else if (player.type === 'green') {
    ctx.fillStyle = "lightgreen";
    ctx.fillText("üü¢ Vert : " + scores.green, 10, 60);
  } else if (player.type === 'cyan') {
    ctx.fillStyle = "cyan";
    ctx.fillText("‚ìÇÔ∏è‚Äã Cyan : " + scores.cyan, 10, 60);
  } else if (player.type === 'yellow') {
    ctx.fillStyle = "gold";
    ctx.fillText("üü° Jaune : " + scores.yellow, 10, 60);
  } else if (player.type === 'purple') {
    ctx.fillStyle = "mediumpurple";
    ctx.fillText("üü£ Violet : " + scores.purple, 10, 60);
  } else if (player.type === 'orange') {
    ctx.fillStyle = "orange";
    ctx.fillText("üü† Orange : " + scores.orange, 10, 60);
  } else if (player.type === 'gray') {
    ctx.fillStyle = "gray";
    ctx.fillText("üîò Gris : " + scores.gray, 10, 60);
  } else if (player.type === 'pink') {
    ctx.fillStyle = "#FF69B4";
    ctx.fillText("üíó Rose : " + scores.pink, 10, 60);
  }
  else if (player.type === 'rubis') {
    ctx.fillStyle = "crimson";
    ctx.fillText("üíé Rubis : " + scores.rubis, 10, 60);
  }
  else if (player.type === 'brown') {
    ctx.fillStyle = "saddlebrown";
    ctx.fillText("üü´ Marron : " + scores.brown, 10, 60);
  }
  // Affichage du multiplicateur de score si actif
  if (scoreMultiplierActive) {
    ctx.fillStyle = "gold";
    ctx.font = "bold 20px Arial";
    ctx.fillText("x" + scoreMultiplier, canvas.width / 2 - 10, 50);
  }

  // Affichage du temps arr√™t√© si actif
  if (timeStopActive) {
    ctx.fillStyle = "#FF69B4";
    ctx.font = "bold 28px Arial";
    ctx.fillText("‚è± TEMPS ARR√äT√â", canvas.width / 2 - 70, 50);
  }

  // Affichage du pouvoir actif et du cooldown
  const now = Date.now();
  let powerText = "";
  let timeRemaining = 0;
  
  if (player.type === 'blue') {
    if (shieldActive) {
      timeRemaining = Math.ceil((shieldDuration - (now - shieldStartTime)) / 1000);
      powerText = `üõ°Ô∏è ACTIF: ${Math.max(1, timeRemaining)}s`;
    } else if (!shieldReady && lastShieldTime) {
      timeRemaining = Math.ceil((shieldCooldown - (now - lastShieldTime)) / 1000);
      powerText = `üõ°Ô∏è Cooldown: ${Math.max(1, timeRemaining)}s`;
    }
  } else if (player.type === 'green') {
    if (flyActive) {
      timeRemaining = Math.ceil((flyDuration - (now - flyStartTime)) / 1000);
      powerText = `üïäÔ∏è ACTIF: ${Math.max(1, timeRemaining)}s`;
    } else if (!flyReady && lastFlyTime) {
      timeRemaining = Math.ceil((flyCooldown - (now - lastFlyTime)) / 1000);
      powerText = `üïäÔ∏è Cooldown: ${Math.max(1, timeRemaining)}s`;
    }
  } else if (player.type === 'yellow') {
    if (scoreMultiplierActive) {
      timeRemaining = Math.ceil((scoreMultiplierDuration - (now - scoreMultiplierStartTime)) / 1000);
      powerText = `‚ö° ACTIF: ${Math.max(1, timeRemaining)}s`;
    } else if (!scoreMultiplierReady && lastScoreMultiplierTime) {
      timeRemaining = Math.ceil((scoreMultiplierCooldown - (now - lastScoreMultiplierTime)) / 1000);
      powerText = `‚ö° Cooldown: ${Math.max(1, timeRemaining)}s`;
    }
  } else if (player.type === 'purple') {
    if (slowmoActive) {
      timeRemaining = Math.ceil((slowmoDuration - (now - slowmoStartTime)) / 1000);
      powerText = `‚è±Ô∏è ACTIF: ${Math.max(1, timeRemaining)}s`;
    } else if (!slowmoReady && lastSlowmoTime) {
      timeRemaining = Math.ceil((slowmoCooldown - (now - lastSlowmoTime)) / 1000);
      powerText = `‚è±Ô∏è Cooldown: ${Math.max(1, timeRemaining)}s`;
    }
  } else if (player.type === 'orange') {
    if (agilityActive) {
      timeRemaining = Math.ceil((agilityDuration - (now - agilityStartTime)) / 1000);
      powerText = `‚ö° ACTIF: ${Math.max(1, timeRemaining)}s`;
    } else if (!agilityReady && lastAgilityTime) {
      timeRemaining = Math.ceil((agilityCooldown - (now - lastAgilityTime)) / 1000);
      powerText = `‚ö° Cooldown: ${Math.max(1, timeRemaining)}s`;
    }
  } else if (player.type === 'cyan') {
    if (magnetActive) {
      timeRemaining = Math.ceil((magnetDuration - (now - magnetStartTime)) / 1000);
      powerText = `üß≤ ACTIF: ${Math.max(1, timeRemaining)}s`;
    } else if (!magnetReady && lastMagnetTime) {
      timeRemaining = Math.ceil((magnetCooldown - (now - lastMagnetTime)) / 1000);
      powerText = `üß≤ Cooldown: ${Math.max(1, timeRemaining)}s`;
    }
  } else if (player.type === 'red') {
    // Afficher le cooldown du tir rouge
    const elapsed = now - lastRedShot;
    if (elapsed >= redCooldown) {
      powerText = 'üî´ READY';
    } else {
      const secs = Math.max(1, Math.ceil((redCooldown - elapsed) / 1000));
      powerText = 'üî´ Cooldown: ' + secs + 's';
    }
  } else if (player.type === 'rubis') {
    // Indiquer l'√©tat des deux pouvoirs du Rubis : tir manuel (üî´) et r√©flexion (üí†)
    const elapsedShot = now - lastRedShot;
    const readyForShot = (elapsedShot >= rubisShotCooldown);
    let shotPart = readyForShot ? 'üî´ READY' : ('üî´ Cooldown: ' + Math.max(1, Math.ceil((rubisShotCooldown - elapsedShot) / 1000)) + 's');
    let reflectPart;
    if (reflectReadyRubis) reflectPart = 'üí† READY';
    else reflectPart = 'üí† Cooldown: ' + Math.max(1, Math.ceil((reflectCooldownRubis - (now - lastReflectTimeRubis)) / 1000)) + 's';
    powerText = shotPart + '  |  ' + reflectPart;
  } else if (player.type === 'saphir') {
    // Indiquer l'√©tat du bouclier Saphir (üõ°Ô∏è) et de la r√©flexion (üí†)
    if (saphirShieldActive) {
      timeRemaining = Math.ceil((saphirShieldDuration - (now - saphirShieldStartTime)) / 1000);
      var shieldPart = `üõ°Ô∏è ACTIF: ${Math.max(1, timeRemaining)}s`;
    } else if (!saphirShieldReady && lastSaphirShieldTime) {
      timeRemaining = Math.ceil((saphirShieldCooldown - (now - lastSaphirShieldTime)) / 1000);
      var shieldPart = `üõ°Ô∏è Cooldown: ${Math.max(1, timeRemaining)}s`;
    } else { var shieldPart = 'üõ°Ô∏è READY'; }
    let reflectPartS;
    if (saphirShieldActive) {
      reflectPartS = 'üí† BLOQU√â';
    } else if (reflectReadySaphir) {
      reflectPartS = 'üí† READY';
    } else {
      reflectPartS = 'üí† Cooldown: ' + Math.max(1, Math.ceil((reflectCooldownSaphir - (now - lastReflectTimeSaphir)) / 1000)) + 's';
    }
    powerText = shieldPart + '  |  ' + reflectPartS;
  } else if (player.type === 'gray') {
    if (shrinkActive) {
      timeRemaining = Math.ceil((shrinkDuration - (now - shrinkStartTime)) / 1000);
      powerText = `‚á≥ ACTIF: ${Math.max(1, timeRemaining)}s`;
    } else if (!shrinkReady && lastShrinkTime) {
      timeRemaining = Math.ceil((shrinkCooldown - (now - lastShrinkTime)) / 1000);
      powerText = `‚á≥ Cooldown: ${Math.max(1, timeRemaining)}s`;
    }
  } else if (player.type === 'pink') {
    if (timeStopActive) {
      timeRemaining = Math.ceil((timeStopDuration - (now - timeStopStartTime)) / 1000);
      powerText = `‚è±Ô∏è ACTIF: ${Math.max(1, timeRemaining)}s`;
    } else if (!timeStopReady && lastTimeStopTime) {
      timeRemaining = Math.ceil((timeStopCooldown - (now - lastTimeStopTime)) / 1000);
      powerText = `‚è±Ô∏è Cooldown: ${Math.max(1, timeRemaining)}s`;
    }
  } else if (player.type === 'brown') {
    if (brownInvincible) {
      timeRemaining = Math.ceil((brownInvincibleEnd - now) / 1000);
      powerText = `üíï ACTIF: ${Math.max(1, timeRemaining)}s`;
    } else if (!brownReady && lastBrownUse) {
      timeRemaining = Math.ceil((brownCooldown - (now - lastBrownUse)) / 1000);
      if (timeRemaining > 0) powerText = `üíï Cooldown: ${Math.max(1, timeRemaining)}s`;
      else { brownReady = true; }
    }
  }
  
  if (powerText) {
    ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
    ctx.font = "14px Arial";
    ctx.fillText(powerText, 10, 80);
  }

  // Mettre √† jour l'affichage DOM du cooldown
  try {
    const pc = document.getElementById('powerCooldown');
    if (pc) pc.textContent = powerText || '';
  } catch (e) {}

  // Gestion du bouclier / recharge
  // Gestion des capacit√©s et de la recharge selon le type s√©lectionn√©
  if (player.type === 'blue') {
    if (!shieldActive && lastShieldTime && now - lastShieldTime > shieldCooldown) shieldReady = true;
    if (shieldActive) {
      rechargeProgress = 0;
    } else if (!shieldReady) {
      rechargeProgress = (now - lastShieldTime) / shieldCooldown;
      if (rechargeProgress >= 1) { rechargeProgress = 1; shieldReady = true; }
    } else rechargeProgress = 1;
  } else if (player.type === 'green') {
    if (!flyActive && lastFlyTime && now - lastFlyTime > flyCooldown) flyReady = true;
    if (flyActive) {
      rechargeProgress = 0;
    } else if (!flyReady) {
      rechargeProgress = (now - lastFlyTime) / flyCooldown;
      if (rechargeProgress >= 1) { rechargeProgress = 1; flyReady = true; }
    } else rechargeProgress = 1;
  } else if (player.type === 'red') {
    // Progression jusqu'au prochain tir automatique
    const elapsed = now - lastRedShot;
    rechargeProgress = Math.min(1, elapsed / redCooldown);
  } else if (player.type === 'saphir') {
    if (!saphirShieldActive && lastSaphirShieldTime && now - lastSaphirShieldTime > saphirShieldCooldown) saphirShieldReady = true;
    if (saphirShieldActive) {
      rechargeProgress = 0;
    } else if (!saphirShieldReady) {
      rechargeProgress = (now - lastSaphirShieldTime) / saphirShieldCooldown;
      if (rechargeProgress >= 1) { rechargeProgress = 1; saphirShieldReady = true; }
    } else rechargeProgress = 1;
  } else if (player.type === 'yellow') {
    if (!scoreMultiplierActive && lastScoreMultiplierTime && now - lastScoreMultiplierTime > scoreMultiplierCooldown) scoreMultiplierReady = true;
    if (scoreMultiplierActive) {
      rechargeProgress = 0;
    } else if (!scoreMultiplierReady) {
      rechargeProgress = (now - lastScoreMultiplierTime) / scoreMultiplierCooldown;
      if (rechargeProgress >= 1) { rechargeProgress = 1; scoreMultiplierReady = true; }
    } else rechargeProgress = 1;
  } else if (player.type === 'gray') {
    if (!shrinkActive && lastShrinkTime && now - lastShrinkTime > shrinkCooldown) shrinkReady = true;
    if (shrinkActive) {
      rechargeProgress = 0;
    } else if (!shrinkReady) {
      rechargeProgress = (now - lastShrinkTime) / shrinkCooldown;
      if (rechargeProgress >= 1) { rechargeProgress = 1; shrinkReady = true; }
    } else rechargeProgress = 1;
  } else if (player.type === 'pink') {
    if (!timeStopActive && lastTimeStopTime && now - lastTimeStopTime > timeStopCooldown) timeStopReady = true;
    if (timeStopActive) {
      rechargeProgress = 0;
    } else if (!timeStopReady) {
      rechargeProgress = (now - lastTimeStopTime) / timeStopCooldown;
      if (rechargeProgress >= 1) { rechargeProgress = 1; timeStopReady = true; }
    } else rechargeProgress = 1;
  } else if (player.type === 'purple') {
    if (!slowmoActive && lastSlowmoTime && now - lastSlowmoTime > slowmoCooldown) slowmoReady = true;
    if (slowmoActive) {
      rechargeProgress = 0;
    } else if (!slowmoReady) {
      rechargeProgress = (now - lastSlowmoTime) / slowmoCooldown;
      if (rechargeProgress >= 1) { rechargeProgress = 1; slowmoReady = true; }
    } else rechargeProgress = 1;
  } else if (player.type === 'orange') {
    if (!agilityActive && lastAgilityTime && now - lastAgilityTime > agilityCooldown) agilityReady = true;
    if (agilityActive) {
      rechargeProgress = 0;
    } else if (!agilityReady) {
      rechargeProgress = (now - lastAgilityTime) / agilityCooldown;
      if (rechargeProgress >= 1) { rechargeProgress = 1; agilityReady = true; }
    } else rechargeProgress = 1;
  } else if (player.type === 'cyan') {
    if (!magnetActive && lastMagnetTime && now - lastMagnetTime > magnetCooldown) magnetReady = true;
    if (magnetActive) {
      rechargeProgress = 0;
    } else if (!magnetReady) {
      rechargeProgress = (now - lastMagnetTime) / magnetCooldown;
      if (rechargeProgress >= 1) { rechargeProgress = 1; magnetReady = true; }
    } else rechargeProgress = 1;
  } else if (player.type === 'red' || player.type === 'rubis') {
    const elapsed = now - lastRedShot;
    const currentShotCooldown = player.type === 'rubis' ? rubisShotCooldown : redCooldown;
    rechargeProgress = Math.min(1, elapsed / currentShotCooldown);
  } else {
    rechargeProgress = 1;
  }

  // Mise √† jour de la barre de recharge : largeur en pourcentage
  document.getElementById('rechargeBarFilled').style.width = (rechargeProgress * 100) + "%";

  // Joueur
  let effectiveGravity = gravity;
  if (slowmoActive) {
    effectiveGravity *= slowmoMultiplier; // r√©duit la gravit√©
  } else if (player.type === 'orange' && agilityActive) {
    effectiveGravity *= (agilityVelocityBoost * agilityVelocityBoost); // augmente la gravit√© au carr√© pour garder la hauteur identique
  }
  player.y += player.velocityY;
  player.velocityY += effectiveGravity;

  if (player.y >= 220) {
    player.y = 220;
    player.velocityY = 0;
    player.jumping = false;
    // Le joueur a atterri : prolonger l'invincibilit√© post-vol pour 2 secondes
    if (flyFalling) {
      // Garder flyFalling = true pour 1,5 secondes apr√®s l'atterrissage
      setTimeout(function() {
        flyFalling = false;
      }, 1500);
    }
  }
  // Effets de vol si actif (vert)
  if (player.type === 'green' && flyActive) {
    // Soulever l√©g√®rement le joueur et neutraliser la gravit√© temporairement
    // Vol plus bas et plus lent
    player.y = Math.max(100, player.y - 1);
    player.velocityY = 0;
  }

  // Couleur et indication du joueur selon le type et l'√©tat
  if (player.type === 'red') {
    ctx.fillStyle = "red";
  } else if (player.type === 'blue') {
    // Le cube bleu est toujours bleu
    ctx.fillStyle = "blue";
  } else if (player.type === 'green') {
    // Le cube vert reste vert m√™me pendant le vol
    ctx.fillStyle = "green";
  } else if (player.type === 'yellow') {
    // Le cube jaune devient plus √©clatant si le multiplicateur est actif
    ctx.fillStyle = scoreMultiplierActive ? "yellow" : "gold";
  } else if (player.type === 'purple') {
    // Le cube violet devient plus lumineux si ralentissement actif
    ctx.fillStyle = slowmoActive ? "#5300A1" : "#5300A1";
  } else if (player.type === 'cyan') {
    // Le cube cyan brille si aimant actif
    ctx.fillStyle = magnetActive ? "#00E5FF" : "cyan";
  } else if (player.type === 'orange') {
    // Le cube orange brille si agilit√© active
    ctx.fillStyle = agilityActive ? "#FF6500" : "#FF9500";
    } else if (player.type === 'gray') {
      // Le cube gris indique son √©tat quand la r√©duction est active
      ctx.fillStyle = shrinkActive ? "#A9A9A9" : "gray";
  } else if (player.type === 'brown') {
    // Le cube marron
    ctx.fillStyle = "brown";
  } else if (player.type === 'rubis') {
    // Rubis : rouge brillant (d√©grad√©)
    const g = ctx.createLinearGradient(player.x, player.y, player.x + player.width, player.y + player.height);
    g.addColorStop(0, '#ff9aa2');
    g.addColorStop(0.4, '#ff4d4d');
    g.addColorStop(1, '#b20000');
    ctx.fillStyle = g;
  } else if (player.type === 'saphir') {
    // Saphir : bleu fonc√© brillant (d√©grad√© renforc√©)
    const gs = ctx.createLinearGradient(player.x, player.y, player.x + player.width, player.y + player.height);
    gs.addColorStop(0, '#cfeeff');
    gs.addColorStop(0.4, '#4aa0ff');
    gs.addColorStop(1, '#002aa6');
    ctx.fillStyle = gs;
    // subtle glow for saphir
    ctx.shadowBlur = 8;
    ctx.shadowColor = 'rgba(10,80,200,0.45)';
    // reset shadow later after fillRect
  } else if (player.type === 'pink') {
    // Le cube rose brille si arr√™t du temps actif
    ctx.fillStyle = timeStopActive ? "#FF1493" : "#FF69B4";
  } else {
    ctx.fillStyle = "white"; // par d√©faut
  }
  ctx.fillRect(player.x, player.y, player.width, player.height);
  // reset any player shadow set for Saphir
  ctx.shadowBlur = 0;
  ctx.shadowColor = 'transparent';
  if (player.type === 'blue' && shieldReady && !shieldActive) {
    ctx.font = "18px Arial";
    const blueReady = "READY";
    ctx.fillStyle = "yellow"; ctx.fillText(blueReady, player.x - 10, player.y - 10);
    ctx.strokeStyle = "yellow"; ctx.lineWidth = 2; ctx.strokeRect(player.x - 5, player.y - 5, player.width + 10, player.height + 10);
  } else if (player.type === 'green' && flyReady && !flyActive) {
    ctx.font = "18px Arial";
    const greenReady = "READY";
    ctx.fillStyle = "yellow"; ctx.fillText(greenReady, player.x - 12, player.y - 10);
    ctx.strokeStyle = "yellow"; ctx.lineWidth = 2; ctx.strokeRect(player.x - 5, player.y - 5, player.width + 10, player.height + 10);
  } else if (player.type === 'red' || player.type === 'rubis') {
    // Indiquer si le tir est pr√™t (rouge / rubis)
    // For Rubis: show a single READY with pistol left and reflection emoji right
    if (player.type === 'rubis') {
      const shotReady = (rechargeProgress >= 1);
      const reflectIsReady = reflectReadyRubis;
      if (shotReady || reflectIsReady) {
        ctx.font = "18px Arial";
        // measure texts
        const readyText = "READY";
        const leftEmoji = shotReady ? "üî´" : "";
        const rightEmoji = reflectIsReady ? "üí†" : "";
        const readyWidth = ctx.measureText(readyText).width;
        const leftWidth = leftEmoji ? ctx.measureText(leftEmoji).width : 0;
        const rightWidth = rightEmoji ? ctx.measureText(rightEmoji).width : 0;
        const padding = 8;
        const centerX = player.x + player.width / 2;
        const readyX = centerX - readyWidth / 2;
        const yPos = player.y - 10;

        // draw left emoji with outline
        if (leftEmoji) {
          ctx.fillStyle = "yellow"; ctx.fillText(leftEmoji, readyX - leftWidth - padding, yPos);
        }

        // draw READY with outline
        ctx.fillStyle = "yellow"; ctx.fillText(readyText, readyX, yPos);

        // draw right emoji with outline
        if (rightEmoji) {
          ctx.fillStyle = "deepskyblue"; ctx.fillText(rightEmoji, readyX + readyWidth + padding, yPos);
        }

        // outline around player
        ctx.strokeStyle = "yellow"; ctx.lineWidth = 2; ctx.strokeRect(player.x - 5, player.y - 5, player.width + 10, player.height + 10);
      }
    } else {
      if (rechargeProgress >= 1) {
        ctx.font = "18px Arial";
        const s = "READY";
        ctx.fillStyle = "yellow"; ctx.fillText(s, player.x - 12, player.y - 10);
        ctx.strokeStyle = "yellow"; ctx.lineWidth = 2; ctx.strokeRect(player.x - 5, player.y - 5, player.width + 10, player.height + 10);
      }
    }

    // Saphir: READY centr√© avec üõ°Ô∏è √† gauche et üí† √† droite (affich√© au m√™me niveau que les autres)
  } else if (player.type === 'saphir') {
    const shieldReadyNow = saphirShieldReady && !saphirShieldActive;
    const reflectReadyNow = reflectReadySaphir && !saphirShieldActive;
      if (shieldReadyNow || reflectReadyNow) {
      ctx.font = "18px Arial";
      const readyText = "READY";
      const leftEmoji = shieldReadyNow ? "üõ°Ô∏è" : "";
      const rightEmoji = reflectReadyNow ? "üí†" : "";
      const readyWidth = ctx.measureText(readyText).width;
      const leftWidth = leftEmoji ? ctx.measureText(leftEmoji).width : 0;
      const rightWidth = rightEmoji ? ctx.measureText(rightEmoji).width : 0;
      const padding = 8;
      const centerX = player.x + player.width / 2;
      const readyX = centerX - readyWidth / 2;
      const yPos = player.y - 10;

      if (leftEmoji) { ctx.fillStyle = "yellow"; ctx.fillText(leftEmoji, readyX - leftWidth - padding, yPos); }
      ctx.fillStyle = "yellow"; ctx.fillText(readyText, readyX, yPos);
      if (rightEmoji) { ctx.fillStyle = "yellow"; ctx.fillText(rightEmoji, readyX + readyWidth + padding, yPos); }

      ctx.strokeStyle = "yellow"; ctx.lineWidth = 2; ctx.strokeRect(player.x - 5, player.y - 5, player.width + 10, player.height + 10);
    }
  } else if (player.type === 'yellow' && scoreMultiplierReady && !scoreMultiplierActive) {
    ctx.font = "18px Arial";
    const ytxt = "READY";
    ctx.fillStyle = "yellow"; ctx.fillText(ytxt, player.x - 20, player.y - 10);
    ctx.strokeStyle = "yellow"; ctx.lineWidth = 2; ctx.strokeRect(player.x - 5, player.y - 5, player.width + 10, player.height + 10);
  } else if (player.type === 'purple' && slowmoReady && !slowmoActive) {
    ctx.font = "18px Arial";
    const ptxt = "READY";
    ctx.fillStyle = "yellow"; ctx.fillText(ptxt, player.x - 12, player.y - 10);
    ctx.strokeStyle = "yellow"; ctx.lineWidth = 2; ctx.strokeRect(player.x - 5, player.y - 5, player.width + 10, player.height + 10);
  } else if (player.type === 'orange' && agilityReady && !agilityActive) {
    ctx.font = "18px Arial";
    const otxt = "READY";
    ctx.fillStyle = "yellow"; ctx.fillText(otxt, player.x - 12, player.y - 10);
    ctx.strokeStyle = "yellow"; ctx.lineWidth = 2; ctx.strokeRect(player.x - 5, player.y - 5, player.width + 10, player.height + 10);
  } else if (player.type === 'cyan' && magnetReady && !magnetActive) {
    ctx.font = "18px Arial";
    const ctxt = "READY";
    ctx.fillStyle = "yellow"; ctx.fillText(ctxt, player.x - 12, player.y - 10);
    ctx.strokeStyle = "yellow"; ctx.lineWidth = 2; ctx.strokeRect(player.x - 5, player.y - 5, player.width + 10, player.height + 10);
  } else if (player.type === 'gray' && shrinkReady && !shrinkActive) {
    ctx.font = "18px Arial";
    const gtxt = "READY";
    ctx.fillStyle = "yellow"; ctx.fillText(gtxt, player.x - 18, player.y - 10);
    ctx.strokeStyle = "yellow"; ctx.lineWidth = 1; ctx.strokeRect(player.x - 5, player.y - 5, player.width + 10, player.height + 10);
  } else if (player.type === 'brown' && brownSecondLifeAvailable && brownReady && !brownInvincible) {
    ctx.font = "18px Arial";
    const btxt = "READY";
    ctx.fillStyle = "yellow"; ctx.fillText(btxt, player.x - 12, player.y - 10);
    ctx.strokeStyle = "yellow"; ctx.lineWidth = 2; ctx.strokeRect(player.x - 5, player.y - 5, player.width + 10, player.height + 10);
  } else if (player.type === 'pink' && timeStopReady && !timeStopActive) {
    ctx.font = "18px Arial";
    const pk = "READY";
    ctx.fillStyle = "yellow"; ctx.fillText(pk, player.x - 12, player.y - 10);
    ctx.strokeStyle = "yellow"; ctx.lineWidth = 2; ctx.strokeRect(player.x - 5, player.y - 5, player.width + 10, player.height + 10);
  }

  // Obstacles
  // Dessiner et g√©rer collisions (si bouclier actif, aucune perte)
  obstacles.forEach((obs, index) => {
    // Si l'arr√™t du temps est actif, les obstacles ne se d√©placent pas
    let effectiveSpeed = timeStopActive ? 0 : obs.speed * (slowmoActive ? slowmoMultiplier : 1);
    
    // Aimant : attirer les obstacles vers le joueur
    if (player.type === 'cyan' && magnetActive) {
      const dx = player.x + player.width / 2 - (obs.x + obs.width / 2);
      const dy = player.y + player.height / 2 - (obs.y + obs.height / 2);
      const distance = Math.sqrt(dx * dx + dy * dy);
      if (distance > 0) {
        const magnetStrength = 8;
        obs.x += (dx / distance) * magnetStrength;
        obs.y += (dy / distance) * magnetStrength;
      }
    } else {
      obs.x += effectiveSpeed;
    }

    // --- V√©rifier collisions entre obstacles si un obstacle r√©fl√©chi touche un autre -> d√©truire les deux
    for (let j = 0; j < obstacles.length; j++) {
      if (j === index) continue;
      const other = obstacles[j];
      if (!other) continue;
      if (obs.reflected &&
          obs.x < other.x + other.width &&
          obs.x + obs.width > other.x &&
          obs.y < other.y + other.height &&
          obs.y + obs.height > other.y) {
        // d√©truire les deux
        const hi = Math.max(index, j);
        const lo = Math.min(index, j);
        obstacles.splice(hi, 1);
        obstacles.splice(lo, 1);
        // R√©compenser le joueur si applicable
        try { if (player.type && scores[player.type] !== undefined) scores[player.type] += 100; } catch (e) {}
        return;
      }
    }
    
    // Couleur des obstacles : orange si agilit√© active (orange),
    // cyan si aimant actif (cyan), bleu si bouclier actif (bleu), sinon blanc
      // Determine drawn size when shrink is active
      const drawW = shrinkActive ? obs.width * shrinkFactor : obs.width;
      const drawH = shrinkActive ? obs.height * shrinkFactor : obs.height;
      const drawX = obs.x + (obs.width - drawW) / 2;
      const drawY = obs.y + (obs.height - drawH) / 2;

      // Si l'obstacle est pr√©-s√©lectionn√© (marqu√©) par le joueur, le remplir en rouge ou rouge-brillant
      if (obs.markedTargetBy === 'red') {
        ctx.save();
        ctx.fillStyle = 'red';
        ctx.shadowBlur = 10;
        ctx.shadowColor = 'rgba(255,0,0,0.5)';
        ctx.fillRect(drawX, drawY, drawW, drawH);
        ctx.restore();
      } else if (obs.markedTargetBy === 'saphir') {
        ctx.save();
        const gb = ctx.createLinearGradient(drawX, drawY, drawX + drawW, drawY + drawH);
        gb.addColorStop(0, '#cfeeff');
        gb.addColorStop(0.5, '#4aa0ff');
        gb.addColorStop(1, '#002aa6');
        ctx.fillStyle = gb;
        ctx.shadowBlur = 18;
        ctx.shadowColor = 'rgba(10,80,200,0.7)';
        ctx.fillRect(drawX, drawY, drawW, drawH);
        ctx.restore();
      } else if (obs.markedTargetBy === 'rubis') {
        ctx.save();
        const g = ctx.createLinearGradient(drawX, drawY, drawX + drawW, drawY + drawH);
        g.addColorStop(0, '#ffd6d6');
        g.addColorStop(0.5, '#ff4d4d');
        g.addColorStop(1, '#ff0000');
        ctx.fillStyle = g;
        ctx.shadowBlur = 16;
        ctx.shadowColor = 'rgba(255,80,80,0.6)';
        ctx.fillRect(drawX, drawY, drawW, drawH);
        ctx.restore();
      } else if (obs.markedTargetBy === 'saphir') {
        ctx.save();
        const gb = ctx.createLinearGradient(drawX, drawY, drawX + drawW, drawY + drawH);
        gb.addColorStop(0, '#e6f8ff');
        gb.addColorStop(0.5, '#66c7ff');
        gb.addColorStop(1, '#0077ff');
        ctx.fillStyle = gb;
        ctx.shadowBlur = 16;
        ctx.shadowColor = 'rgba(80,140,255,0.55)';
        ctx.fillRect(drawX, drawY, drawW, drawH);
        ctx.restore();
      } else if (player.type === 'orange' && agilityActive) {
        ctx.fillStyle = "orange";
        ctx.fillRect(drawX, drawY, drawW, drawH);
      } else if (player.type === 'cyan' && magnetActive) {
        ctx.fillStyle = "cyan";
        ctx.fillRect(drawX, drawY, drawW, drawH);
      } else if (player.type === 'green' && (flyActive || flyFalling)) {
        // Quand le vert est invincible, colorer les obstacles en vert fonc√©
        ctx.fillStyle = "#006400";
        ctx.fillRect(drawX, drawY, drawW, drawH);
      } else {
        // Si bouclier bleu ou bouclier saphir actif, rendre les obstacles bleu brillant
        if ((player.type === 'blue' && shieldActive) || (player.type === 'saphir' && saphirShieldActive)) {
          ctx.save();
          const gb2 = ctx.createLinearGradient(drawX, drawY, drawX + drawW, drawY + drawH);
          gb2.addColorStop(0, '#cfeeff');
          gb2.addColorStop(0.4, '#4aa0ff');
          gb2.addColorStop(1, '#002aa6');
          ctx.fillStyle = gb2;
          ctx.shadowBlur = 20;
          ctx.shadowColor = 'rgba(30,100,255,0.7)';
          ctx.fillRect(drawX, drawY, drawW, drawH);
          ctx.restore();
        } else {
          ctx.fillStyle = 'white';
          ctx.fillRect(drawX, drawY, drawW, drawH);
        }
      }

    // Nettoyage hors-√©cran (garder ce check m√™me si le joueur est en vol)
    if (obs.x < -50 || obs.x > canvas.width + 50) {
      obstacles.splice(index, 1);
      return;
    }

    // Si le joueur est le cube vert en vol ou en descente post-vol, il est invincible :
    // on ignore les collisions (les obstacles passent sous le joueur).
    if (player.type === 'green' && (flyActive || flyFalling)) {
      return; // continue
    }
    // Si le joueur est le cube marron et qu'il est en invincibilit√© post-seconde-vie, ignorer collisions
    if (player.type === 'brown' && brownInvincible) {
      return;
    }

    // R√©flexion Rubis (si joueur est rubis)
    if (player.type === 'rubis' && reflectReadyRubis) {
      // V√©rifier collision AABB entre le joueur et l'obstacle
      const collidesWithPlayerRubis = (
        player.x < obs.x + obs.width &&
        player.x + player.width > obs.x &&
        player.y < obs.y + obs.height &&
        player.y + player.height > obs.y
      );
      if (collidesWithPlayerRubis) {
        // R√©fl√©ter l'obstacle : inverser sa vitesse et le replacer l√©g√®rement de l'autre c√¥t√© du joueur
        obs.speed = -obs.speed;
        obs.reflected = true;
        if (obs.speed > 0) {
          obs.x = player.x + player.width + 4;
        } else {
          obs.x = player.x - obs.width - 4;
        }
        // d√©marrer cooldown de r√©flexion pour Rubis
        reflectReadyRubis = false;
        lastReflectTimeRubis = Date.now();
        setTimeout(function() { reflectReadyRubis = true; }, reflectCooldownRubis);
        // ne pas toucher le joueur
        return;
      }
    }

    // R√©flexion Saphir (comportement propre)
    if (player.type === 'saphir' && reflectReadySaphir && !saphirShieldActive) {
      const collidesWithPlayerSaphir = (
        player.x < obs.x + obs.width &&
        player.x + player.width > obs.x &&
        player.y < obs.y + obs.height &&
        player.y + player.height > obs.y
      );
      if (collidesWithPlayerSaphir) {
        // R√©fl√©ter l'obstacle avec un peu plus de force (pousse plus vite)
        obs.speed = -obs.speed * 1.2;
        obs.reflected = true;
        if (obs.speed > 0) {
          obs.x = player.x + player.width + 6;
        } else {
          obs.x = player.x - obs.width - 6;
        }
        // d√©marrer cooldown de r√©flexion pour Saphir
        reflectReadySaphir = false;
        lastReflectTimeSaphir = Date.now();
        setTimeout(function() { reflectReadySaphir = true; }, reflectCooldownSaphir);
        // ne pas toucher le joueur
        return;
      }
    }

    // Collision (trait√©e normalement pour les autres cas)
    if (
      player.x < drawX + drawW &&
      player.x + player.width > drawX &&
      player.y < drawY + drawH &&
      player.y + player.height > drawY
    ) {
      if (player.type === 'blue' && shieldActive) {
        // neutralis√© par le bouclier
        scores['blue'] += 100; // Ajouter 100 points au score
        obstacles.splice(index, 1);
      } else if (player.type === 'cyan' && magnetActive) {
        // neutralis√© par l'aimant
        scores['cyan'] += 100; // Ajouter 100 points au score
        obstacles.splice(index, 1);
      } else if (player.type === 'saphir' && saphirShieldActive) {
        // neutralis√© par le bouclier du Saphir
        try { if (player && player.type && scores[player.type] !== undefined) scores[player.type] += 150; } catch (e) { scores['saphir'] += 150; }
        obstacles.splice(index, 1);
      } else if (player.type === 'brown' && brownSecondLifeAvailable) {
          // Utilise la seconde vie : neutralise cet obstacle, active invincibilit√© courte
          brownSecondLifeAvailable = false;
          brownInvincible = true;
          brownReady = false;
          // Le cooldown commence maintenant
          lastBrownUse = Date.now();
          obstacles.splice(index, 1);
          brownInvincibleStart = Date.now();
          brownInvincibleEnd = brownInvincibleStart + brownInvincibleDuration;
          // Fin de l'invincibilit√© apr√®s la courte dur√©e
          setTimeout(function() {
            brownInvincible = false;
          }, brownInvincibleDuration);
          // Restaure la seconde vie et le ready apr√®s brownCooldown (30s)
          setTimeout(function() {
            brownReady = true;
            brownSecondLifeAvailable = true;
          }, brownCooldown);
      } else if (player.type === 'red') {
        
        
        // collision normale (si red n'a pas de bouclier) -> game over
        gameOver = true; gameOverScreen();
      } else {
        gameOver = true; gameOverScreen();
      }
    }
  });

  requestAnimationFrame(update);
}

// Afficher les meilleurs niveaux au d√©marrage
updateBestLevelsDisplay();

update();

// V√©rifier si au moins 5 cubes Classiques sont au niveau 100
function canUnlockBrillant() {
  const classicCubes = ['red', 'blue', 'green', 'cyan', 'yellow', 'purple', 'orange', 'gray', 'pink', 'brown'];
  let level100Count = 0;
  classicCubes.forEach(color => {
    const level = getLevelFromScore(bestScores[color] || 0);
    if (level >= 100) level100Count++;
  });
  return level100Count >= 5;
}

// Changer le mode d'affichage du s√©lecteur (classique / brillant)
function changeSelectorMode(mode) {
  const classic = document.getElementById('classicGrid');
  const brilliant = document.getElementById('brilliantGrid');
  if (!classic || !brilliant) return;
  if (mode === 'classique') {
    classic.style.display = 'grid';
    brilliant.style.display = 'none';
  } else if (mode === 'brillant') {
    // V√©rifier le d√©verrouillage avant d'afficher
    if (!canUnlockBrillant()) {
      alert('üîí Vous devez avoir au moins 5 cubes Classiques au niveau 100 pour d√©verrouiller les cubes Brillant!');
      // Revenir √† Classique
      document.getElementById('selectorMode').value = 'classique';
      classic.style.display = 'grid';
      brilliant.style.display = 'none';
      return;
    }
    classic.style.display = 'none';
    brilliant.style.display = 'block';
  }
}

// Initialiser l'√©tat du s√©lecteur au chargement
document.addEventListener('DOMContentLoaded', function() {
  try { changeSelectorMode(document.getElementById('selectorMode').value); } catch (e) {}
});
</script>

</body>
</html>







