<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Jeu d'Esquive</title>
<style>
  body {
    background: #111;
    display: flex;
    justify-content: center;
    align-items: flex-start;
    height: 100vh;
    margin: 0;
    padding-top: 200px;
  }

  canvas {
    background: #222;
    border: 2px solid white;
  }

  /* Bouton Classement (droite) */
  #leaderboardBtn {
    position: absolute;
    top: 50%;
    right: 16px;
    transform: translateY(-50%);
    background: linear-gradient(135deg,#667eea 0%,#764ba2 100%);
    color: white;
    padding: 10px 14px;
    border-radius: 10px;
    text-decoration: none;
    font-weight: 700;
    box-shadow: 0 8px 24px rgba(0,0,0,0.35);
    z-index: 50;
  }
  #leaderboardBtn:hover { transform: translateY(-50%) translateY(-4px); }

  @media (max-width: 600px) {
    #leaderboardBtn { top: auto; bottom: 16px; right: 16px; transform: none; }
  }

  /* Barre de recharge du double saut */
  #rechargeBar {
    position: absolute;
    bottom: 10px;
    left: 10px;
    width: 200px;
    height: 20px;
    background-color: #444;
    border: 1px solid #fff;
  }

  #rechargeBarFilled {
    height: 100%;
    background-color: #0f0; /* Couleur de la barre de recharge */
  }

  /* Affichage du meilleur rang dans le coin bas √† droite */
  #bestRank {
    position: absolute;
    bottom: 10px;
    right: 10px;
    color: white;
    font-size: 16px;
    font-family: Arial, sans-serif;
  }
</style>
</head>
<body>

<canvas id="game" width="600" height="300"></canvas>
<div id="rechargeBar"><div id="rechargeBarFilled"></div></div>
<div id="bestRank"></div>

<!-- Bouton acc√®s classement (ouvre le fichier local dans un nouvel onglet) -->
<a id="leaderboardBtn" href="file:///C:/Users/pezet/Documents/Bounce/leaderboard.html" target="_blank" rel="noopener noreferrer" title="Voir le classement">üèÜ Classement</a>

<!-- S√©lecteur de cube -->
<div id="selector" style="position:absolute;top:20px;left:50%;transform:translateX(-50%);z-index:10;text-align:center;width:90%;display:flex;flex-direction:column;align-items:center;">
  <div style="margin-bottom:10px;font-size:18px;color:#fff;font-weight:bold;">Choisis un cube :</div>
  <div style="display:flex;flex-wrap:wrap;justify-content:center;gap:3px;max-width:700px;">
  <button id="redBtn" onclick="selectType('red')" style="background:red;color:#fff;border:none;padding:10px 14px;font-size:16px;margin:5px;border-radius:8px;"><div>üî¥ Rouge</div><div style="font-size:12px;margin-top:5px;">Meilleur : Niveau <span id="redLevel">1</span></div></button>
  <button id="blueBtn" onclick="selectType('blue')" style="background:blue;color:#fff;border:none;padding:10px 14px;font-size:16px;margin:5px;border-radius:8px;"><div>üîµ Bleu</div><div style="font-size:12px;margin-top:5px;">Meilleur : Niveau <span id="blueLevel">1</span></div></button>
  <button id="greenBtn" onclick="selectType('green')" style="background:green;color:#fff;border:none;padding:10px 14px;font-size:16px;margin:5px;border-radius:8px;"><div>üü¢ Vert</div><div style="font-size:12px;margin-top:5px;">Meilleur : Niveau <span id="greenLevel">1</span></div></button>
  <button id="orangeBtn" onclick="selectType('orange')" style="background:orange;color:#000;border:none;padding:10px 14px;font-size:16px;margin:5px;border-radius:8px;"><div>üü† Orange</div><div style="font-size:12px;margin-top:5px;">Meilleur : Niveau <span id="orangeLevel">1</span></div></button>
  <button id="cyanBtn" onclick="selectType('cyan')" style="background:cyan;color:#000;border:none;padding:10px 14px;font-size:16px;margin:5px;border-radius:8px;"><div><span style="display:inline-block;width:18px;height:18px;border-radius:50%;background:cyan;border:1px solid #000;vertical-align:middle;margin-right:8px;"></span> Cyan</div><div style="font-size:12px;margin-top:5px;">Meilleur : Niveau <span id="cyanLevel">1</span></div></button>
  <button id="yellowBtn" onclick="selectType('yellow')" style="background:gold;color:#000;border:none;padding:10px 14px;font-size:16px;margin:5px;border-radius:8px;"><div>üü° Jaune</div><div style="font-size:12px;margin-top:5px;">Meilleur : Niveau <span id="yellowLevel">1</span></div></button>
  <button id="purpleBtn" onclick="selectType('purple')" style="background:purple;color:#fff;border:none;padding:10px 14px;font-size:16px;margin:5px;border-radius:8px;"><div>üü£ Violet</div><div style="font-size:12px;margin-top:5px;">Meilleur : Niveau <span id="purpleLevel">1</span></div></button>
  <button id="grayBtn" onclick="selectType('gray')" style="background:gray;color:#fff;border:none;padding:10px 14px;font-size:16px;margin:5px;border-radius:8px;"><div style="display:flex;align-items:center;gap:6px;"><span style="display:inline-block;width:18px;height:18px;border-radius:50%;background:gray;border:1px solid #000;vertical-align:middle;margin-left:23px;"></span> Gris</div><div style="font-size:12px;margin-top:5px;">Meilleur : Niveau <span id="grayLevel">1</span></div></button>
  </div>
</div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

// ====== JOUEUR ======
let player = {
  x: canvas.width / 2 - 15,
  y: 220,
  width: 30,
  height: 30,
  velocityY: 0,
  jumping: false,
  doubleJumpUsed: false // Flag pour savoir si le double saut a √©t√© utilis√©
};

let gravity = 0.8;
let obstacles = [];
let gameOver = false;

// ====== SCORE ======
// Scores par cube (individuels)
  let scores = { red: 0, blue: 0, green: 0, yellow: 0, purple: 0, orange: 0, cyan: 0, gray: 0 }; // Scores par cube (individuels)
let bestScore = localStorage.getItem("bestScore") || 0;

// Meilleurs scores pour chaque cube
let bestScores = {
  red: localStorage.getItem("bestScore_red") || 0,
  blue: localStorage.getItem("bestScore_blue") || 0,
  green: localStorage.getItem("bestScore_green") || 0,
  yellow: localStorage.getItem("bestScore_yellow") || 0,
  purple: localStorage.getItem("bestScore_purple") || 0,
  orange: localStorage.getItem("bestScore_orange") || 0,
  cyan: localStorage.getItem("bestScore_cyan") || 0,
  gray: localStorage.getItem("bestScore_gray") || 0
};



// ====== DIFFICULT√â ======
let obstacleSpeed = 6;
let spawnRate = 1500; // Spawn des obstacles toutes les 1,5 secondes initialement

// ====== BOUCLIER / INVINCIBILIT√â (BLEU) ======
let shieldActive = false; // Invincibilit√© en cours
let shieldReady = true; // Le bouclier est pr√™t √† √™tre utilis√©
let shieldDuration = 2000; // Dur√©e du bouclier en ms (2 secondes)
let shieldCooldown = 10000; // Cooldown en ms (10 secondes)
let lastShieldTime = 0; // Moment o√π le bouclier s'est termin√© (d√©but du cooldown)
let rechargeProgress = 1; // La barre est pleine au d√©but (valeur entre 0 et 1)

// ====== VOL (VERT) ======
let flyActive = false;
let flyReady = true;
let flyDuration = 2000; // 2s
let flyCooldown = 7000; // 7s
let lastFlyTime = 0;
let flyFalling = false; // Invincibilit√© pendant la descente apr√®s le vol

// ====== RALENTISSEMENT (VIOLET) ======
let slowmoActive = false;
let slowmoReady = true;
let slowmoDuration = 3000; // 3s
let slowmoCooldown = 14000; // 14s
let lastSlowmoTime = 0;
let slowmoMultiplier = 0.5; // Ralentir √† 50% de la vitesse

// ====== AGILIT√â ACCRUE (ORANGE) ======
let agilityActive = false;
let agilityReady = true;
let agilityDuration = 3000; // 3s
let agilityCooldown = 10000; // 10s
let lastAgilityTime = 0;
let agilityVelocityBoost = 1.3; // Augmente la v√©locit√© du saut de 30% (plus rapide mais meme hauteur)

// ====== TIR (ROUGE) ======
let redInterval = null;
let lastRedShot = 1;
let redCooldown = 5000; // 5s

// ====== MULTIPLICATEUR DE SCORE (JAUNE) ======
let scoreMultiplierActive = false;
let scoreMultiplierReady = true;
let scoreMultiplierDuration = 3000; // 3s
let scoreMultiplierCooldown = 12000; // 12s
let lastScoreMultiplierTime = 0;
let scoreMultiplier = 1; // Multiplicateur du score (1 = normal, 3 = triple gain)

// ====== AIMANT D'OBSTACLES (CYAN) ======
let magnetActive = false;
let magnetReady = true;
let magnetDuration = 2000; // 2s
let magnetCooldown = 10000; // 10s
let lastMagnetTime = 0;

// ====== R√âDUCTION D'OBSTACLES (GRIS) ======
let shrinkActive = false;
let shrinkReady = true;
let shrinkDuration = 4000; // 4s
let shrinkCooldown = 13000; // 13s
let lastShrinkTime = 0;
let shrinkFactor = 0.5; // obstacles rendered at 50% size when active

// ====== COURONNES POUR LES NIVEAUX ======
let currentLevels = { red: 1, blue: 1, green: 1, yellow: 1, purple: 1, orange: 1 };
let levelUpFlags = { red: false, blue: false, green: false, yellow: false, purple: false, orange: false };

// ====== NIVEAUX PAR CUBE ======
// Chaque palier de 1000 points augmente d'1 niveau, niveaux 1..100
function getLevelFromScore(s) {
  return Math.min(100, Math.floor(s / 1000) + 1);
}

// ====== SAUT (CLIC / TAP) ======
function jump() {
  if (!player.jumping) {
    // Premier saut
    let jumpForce = -15;
    // Agilit√© accrue : saute plus rapidement (v√©locit√© augment√©e)
    if (player.type === 'orange' && agilityActive) {
      jumpForce *= agilityVelocityBoost;
    }
    player.velocityY = jumpForce;
    player.jumping = true;
    // R√©initialise les flags li√©s au bouclier si besoin
  } else {
    // Si le joueur clique en l'air et que le pouvoir est pr√™t, l'activer
    activateAbility();
  }
}

// Saut n'importe o√π sur l'√©cran avec clic gauche ou touch (sauf sur les boutons de s√©lection)
document.addEventListener("mousedown", function(e) {
  // Ignorer les clics sur les boutons
  if (e.target.tagName === 'BUTTON' || e.target.closest('button')) return;
  if (e.button === 0) jump();
});
document.addEventListener("touchstart", function(e) {
  // Ignorer les touches sur les boutons
  if (e.target.tagName === 'BUTTON' || e.target.closest('button')) return;
  e.preventDefault();
  jump();
}, { passive: false });

// Activer le pouvoir avec le clic droit n'importe o√π sur l'√©cran (sauf sur les boutons de s√©lection)
document.addEventListener('contextmenu', function(e) {
  // Ignorer les clics droit sur les boutons
  if (e.target.tagName === 'BUTTON' || e.target.closest('button')) return;
  e.preventDefault();
  activateAbility();
});

// Activer le bouclier d'invincibilit√©
// Activer le pouvoir en fonction du type s√©lectionn√©
function activateAbility() {
  if (!player.type) return;
  if (player.type === 'blue') {
    if (!shieldReady || shieldActive) return;
    shieldActive = true;
    shieldReady = false;
    setTimeout(function() {
      shieldActive = false;
      lastShieldTime = Date.now();
    }, shieldDuration);
  } else if (player.type === 'green') {
    if (!flyReady || flyActive) return;
    flyActive = true;
    flyReady = false;
    // D√©sactiver la gravit√© pendant la dur√©e
    setTimeout(function() {
      flyActive = false;
      // Activer une courte invincibilit√© pendant la descente
      flyFalling = true;
      lastFlyTime = Date.now();
    }, flyDuration);
  } else if (player.type === 'yellow') {
    if (!scoreMultiplierReady || scoreMultiplierActive) return;
    scoreMultiplierActive = true;
    scoreMultiplierReady = false;
    scoreMultiplier = 3; // Triple le gain de score
    setTimeout(function() {
      scoreMultiplierActive = false;
      scoreMultiplier = 1;
      lastScoreMultiplierTime = Date.now();
    }, scoreMultiplierDuration);
  } else if (player.type === 'purple') {
    if (!slowmoReady || slowmoActive) return;
    slowmoActive = true;
    slowmoReady = false;
    setTimeout(function() {
      slowmoActive = false;
      lastSlowmoTime = Date.now();
    }, slowmoDuration);
  } else if (player.type === 'orange') {
    if (!agilityReady || agilityActive) return;
    agilityActive = true;
    agilityReady = false;
    setTimeout(function() {
      agilityActive = false;
      lastAgilityTime = Date.now();
    }, agilityDuration);
  }
  else if (player.type === 'gray') {
    if (!shrinkReady || shrinkActive) return;
    shrinkActive = true;
    shrinkReady = false;
    setTimeout(function() {
      shrinkActive = false;
      lastShrinkTime = Date.now();
    }, shrinkDuration);
  }
  else if (player.type === 'cyan') {
    if (!magnetReady || magnetActive) return;
    magnetActive = true;
    magnetReady = false;
    setTimeout(function() {
      magnetActive = false;
      lastMagnetTime = Date.now();
    }, magnetDuration);
  }
  else if (player.type === 'red') {
    // Tir manuel pour le rouge si recharge pr√™te
    const now = Date.now();
    if (now - lastRedShot >= redCooldown) {
      autoShoot();
      lastRedShot = now;
    }
  }
}

// ====== OBSTACLES ======
function createObstacle() {
  // Ne pas cr√©er d'obstacles tant que le joueur n'a pas choisi son cube
  if (!player.type) return false;

  let side = Math.random() < 0.5 ? "left" : "right";
  obstacles.push({
    x: side === "left" ? -30 : canvas.width,
    y: 220,
    width: 30,
    height: 30,
    speed: side === "left" ? obstacleSpeed : -obstacleSpeed
  });
  return true;
}

// S√©lectionner le type de joueur
function selectType(t) {
  player.type = t;
  // Verrouiller le choix : d√©sactiver tous les boutons du s√©lecteur
  const btns = document.querySelectorAll('#selector button');
  btns.forEach(b => {
    b.disabled = true;
    b.style.opacity = '0.5';
    b.style.cursor = 'not-allowed';
  });
  // Nettoyer √©tat pr√©c√©dent
  if (redInterval) { clearInterval(redInterval); redInterval = null; }

  if (t === 'red') {
    // Passage en mode rouge : tir MANUEL. rendre le tir imm√©diatement pr√™t
    lastRedShot = Date.now() - redCooldown;
  } else if (t === 'blue') {
    // r√©initialiser bouclier
    shieldActive = false; shieldReady = true; lastShieldTime = 0;
  } else if (t === 'green') {
    flyActive = false; flyReady = true; lastFlyTime = 0;
  } else if (t === 'yellow') {
    // r√©initialiser multiplicateur de score
    scoreMultiplierActive = false; scoreMultiplierReady = true; lastScoreMultiplierTime = 0; scoreMultiplier = 1;
  } else if (t === 'purple') {
    // r√©initialiser ralentissement
    slowmoActive = false; slowmoReady = true; lastSlowmoTime = 0;
  } else if (t === 'orange') {
    // r√©initialiser agilit√©
    agilityActive = false; agilityReady = true; lastAgilityTime = 0;
  } else if (t === 'cyan') {
    // r√©initialiser aimant
    magnetActive = false; magnetReady = true; lastMagnetTime = 0;
  } else if (t === 'gray') {
    // r√©initialiser r√©duction
    shrinkActive = false; shrinkReady = true; lastShrinkTime = 0;
  }
}

// Mettre √† jour l'affichage des meilleurs niveaux
function updateBestLevelsDisplay() {
  // Mettre √† jour les niveaux et d√©tecter les level-ups
  ['red', 'blue', 'green', 'cyan', 'yellow', 'purple', 'orange', 'gray'].forEach(color => {
    const newLevel = getLevelFromScore(bestScores[color]);
    const levelElement = document.getElementById(color + 'Level');
    
    if (newLevel > currentLevels[color]) {
      // Level up !
      currentLevels[color] = newLevel;
      levelUpFlags[color] = true;
      levelElement.textContent = newLevel + " üëë";
    } else {
      levelElement.textContent = newLevel;
    }
  });
}

// Tir automatique pour le cube rouge : neutralise le bloc le plus proche devant le joueur
function autoShoot() {
  if (obstacles.length === 0) return;
  // Trouver l'obstacle le plus proche horizontalement
  let bestIndex = -1;
  let bestDist = Infinity;
  for (let i = 0; i < obstacles.length; i++) {
    const obs = obstacles[i];
    const dx = Math.abs((obs.x + obs.width/2) - (player.x + player.width/2));
    const dy = Math.abs((obs.y + obs.height/2) - (player.y + player.height/2));
    if (dx < 200 && dy < 50 && dx < bestDist) {
      bestDist = dx; bestIndex = i;
    }
  }
  if (bestIndex !== -1) {
    // Supprimer l'obstacle touch√©
    scores['red'] += 100; // Ajouter 100 points au score
    obstacles.splice(bestIndex, 1);
    // Optionnel : flash ou effet (simple cercle)
    // draw shot effect briefly
  }
}

// ====== BOUCLE DE JEU ======
let gameStartTime = Date.now(); // Enregistrer le moment o√π le jeu commence

let lastObstacleTime = 0;
let obstacleInterval = setInterval(() => {
  let now = Date.now();
  // Ralentir le spawnRate si le violet est actif
  let effectiveSpawnRate = slowmoActive ? spawnRate / slowmoMultiplier : spawnRate;
  if (now - lastObstacleTime >= effectiveSpawnRate) {
    const created = createObstacle();
    if (created) lastObstacleTime = now;
  }
}, 100); // V√©rifie chaque 100ms pour √©viter les regroupements

// R√©duit progressivement le spawnRate toutes les 10 secondes
setInterval(() => {
  let elapsedTime = Date.now() - gameStartTime; // Temps √©coul√© depuis le d√©but du jeu

  if (elapsedTime >= 10000) { // Si plus de 10 secondes se sont √©coul√©es
    // On diminue le spawnRate de 100 ms toutes les 10 secondes
    spawnRate = Math.max(700, spawnRate - 100); // Ne pas descendre en dessous de 700 ms
    obstacleSpeed += 0.1; // Augmenter la vitesse des obstacles

    // Le spawnRate est mis √† jour, le nouvel intervalle s'applique automatiquement

    // R√©initialiser le moment de r√©f√©rence pour la prochaine r√©duction
    gameStartTime = Date.now();
  }
}, 10000); // V√©rifie toutes les 10 secondes (10000 ms)

// ====== FONCTION DE RANG ======
function getRank(score) {
  if (score < 2000) return "D√©butant";
  if (score < 5000) return "Novice";
  if (score < 10000) return "Interm√©diaire";
  if (score < 20000) return "Avanc√©";
  if (score < 50000) return "Expert";
  if (score >= 50000) return "Ma√Ætre";
}

// ====== SOUMETTRE UN SCORE ======
async function submitScore(playerName, score, cubeType) {
  try {
    const response = await fetch('http://localhost:3000/api/score', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        playerName: playerName,
        score: score,
        type: cubeType
      })
    });

    if (response.ok) {
      const data = await response.json();
      alert('‚úÖ ' + data.message + '\n\nüëâ Voir le classement: http://localhost:3000/leaderboard');
      return true;
    } else {
      alert('‚ùå Erreur lors de l\'enregistrement du score');
      return false;
    }
  } catch (error) {
    console.error('Error:', error);
    // Fallback: stocker en localStorage si le serveur ne r√©pond pas
    let leaderboard = JSON.parse(localStorage.getItem('leaderboard') || '[]');
    leaderboard.push({
      playerName: playerName.substring(0, 50),
      score: parseInt(score),
      type: cubeType,
      timestamp: new Date().toISOString()
    });
    localStorage.setItem('leaderboard', JSON.stringify(leaderboard));
    alert('‚úÖ Score enregistr√© localement!\n(Le serveur ne r√©pond pas)');
    return true;
  }
}

// ====== GAME OVER ======
function gameOverScreen() {
  if (scores[player.type] > bestScores[player.type]) {
    bestScores[player.type] = scores[player.type];
    localStorage.setItem("bestScore_" + player.type, bestScores[player.type]);
  }
  
  if (scores[player.type] > bestScore) {
    bestScore = scores[player.type];
    localStorage.setItem("bestScore", bestScore);
  }
  
  let rank = getRank(scores[player.type]);
  
  alert(
    "üíÄ GAME OVER\n" +
    "Score : " + scores[player.type] + "\n" +
    "Meilleur score cube : " + bestScores[player.type] + "\n" +
    "Meilleur score global : " + bestScore + "\n" +
    "Rang atteint : " + rank + "\n\n" +
    "Meilleurs niveaux par cube :\n" +
    "üî¥ Rouge : " + getLevelFromScore(bestScores.red) + "\n" +
    "üîµ Bleu : " + getLevelFromScore(bestScores.blue) + "\n" +
    "üü¢ Vert : " + getLevelFromScore(bestScores.green) + "\n" +
    "üî∑ Cyan : " + getLevelFromScore(bestScores.cyan) + "\n" +
    "üü° Jaune : " + getLevelFromScore(bestScores.yellow) + "\n" +
    "üü£ Violet : " + getLevelFromScore(bestScores.purple) + "\n" +
    "üü† Orange : " + getLevelFromScore(bestScores.orange) + "\n" +
    "üîò Gris : " + getLevelFromScore(bestScores.gray)
  );

  // Proposer de soumettre le score
  const submitConfirm = confirm("üìä Voulez-vous soumettre votre score au classement mondial?");
  if (submitConfirm) {
    const playerName = prompt("Quel est votre pseudo? (max 50 caract√®res)", "Joueur");
    if (playerName && playerName.trim()) {
      submitScore(playerName.trim(), scores[player.type], player.type);
    }
  }

  location.reload();
}

// ====== BOUCLE DE JEU ======
function update() {
  if (gameOver) return;

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Score (n'augmente que si le joueur a choisi un cube)
  if (player.type) scores[player.type] += 5 * scoreMultiplier;
  const totalScore = scores.red + scores.blue + scores.green + scores.yellow + scores.purple + scores.orange + scores.cyan + scores.gray;
  
  // Mettre √† jour l'affichage des couronnes en temps r√©el
  updateBestLevelsDisplay();

  ctx.fillStyle = "white";
  ctx.font = "16px Arial";
  ctx.fillText("Meilleur score : " + bestScore, 10, 20);
  ctx.fillText("Niveaux R/B/V/BL/J/P/O/G : " + getLevelFromScore(scores.red) + " / " + getLevelFromScore(scores.blue) + " / " + getLevelFromScore(scores.green) + " / " + getLevelFromScore(scores.cyan) + " / " + getLevelFromScore(scores.yellow) + " / " + getLevelFromScore(scores.purple) + " / " + getLevelFromScore(scores.orange) + " / " + getLevelFromScore(scores.gray), 10, 40);
  
  // Afficher le score du cube s√©lectionn√©
  if (player.type === 'red') {
    ctx.fillStyle = "red";
    ctx.fillText("üî¥ Rouge : " + scores.red, 10, 60);
  } else if (player.type === 'blue') {
    ctx.fillStyle = "lightblue";
    ctx.fillText("üîµ Bleu : " + scores.blue, 10, 60);
  } else if (player.type === 'green') {
    ctx.fillStyle = "lightgreen";
    ctx.fillText("üü¢ Vert : " + scores.green, 10, 60);
  } else if (player.type === 'cyan') {
    ctx.fillStyle = "cyan";
    ctx.fillText("‚ìÇÔ∏è‚Äã Cyan : " + scores.cyan, 10, 60);
  } else if (player.type === 'yellow') {
    ctx.fillStyle = "gold";
    ctx.fillText("üü° Jaune : " + scores.yellow, 10, 60);
  } else if (player.type === 'purple') {
    ctx.fillStyle = "mediumpurple";
    ctx.fillText("üü£ Violet : " + scores.purple, 10, 60);
  } else if (player.type === 'orange') {
    ctx.fillStyle = "orange";
    ctx.fillText("üü† Orange : " + scores.orange, 10, 60);
  } else if (player.type === 'gray') {
    ctx.fillStyle = "gray";
    ctx.fillText("üîò Gris : " + scores.gray, 10, 60);
  }
  // Affichage du multiplicateur de score si actif
  if (scoreMultiplierActive) {
    ctx.fillStyle = "gold";
    ctx.font = "bold 20px Arial";
    ctx.fillText("x" + scoreMultiplier, canvas.width / 2 - 10, 50);
  }

  // Gestion du bouclier / recharge
  // Gestion des capacit√©s et de la recharge selon le type s√©lectionn√©
  const now = Date.now();
  if (player.type === 'blue') {
    if (!shieldActive && lastShieldTime && now - lastShieldTime > shieldCooldown) shieldReady = true;
    if (shieldActive) {
      rechargeProgress = 0;
    } else if (!shieldReady) {
      rechargeProgress = (now - lastShieldTime) / shieldCooldown;
      if (rechargeProgress >= 1) { rechargeProgress = 1; shieldReady = true; }
    } else rechargeProgress = 1;
  } else if (player.type === 'green') {
    if (!flyActive && lastFlyTime && now - lastFlyTime > flyCooldown) flyReady = true;
    if (flyActive) {
      rechargeProgress = 0;
    } else if (!flyReady) {
      rechargeProgress = (now - lastFlyTime) / flyCooldown;
      if (rechargeProgress >= 1) { rechargeProgress = 1; flyReady = true; }
    } else rechargeProgress = 1;
  } else if (player.type === 'red') {
    // Progression jusqu'au prochain tir automatique
    const elapsed = now - lastRedShot;
    rechargeProgress = Math.min(1, elapsed / redCooldown);
  } else if (player.type === 'yellow') {
    if (!scoreMultiplierActive && lastScoreMultiplierTime && now - lastScoreMultiplierTime > scoreMultiplierCooldown) scoreMultiplierReady = true;
    if (scoreMultiplierActive) {
      rechargeProgress = 0;
    } else if (!scoreMultiplierReady) {
      rechargeProgress = (now - lastScoreMultiplierTime) / scoreMultiplierCooldown;
      if (rechargeProgress >= 1) { rechargeProgress = 1; scoreMultiplierReady = true; }
    } else rechargeProgress = 1;
  } else if (player.type === 'gray') {
    if (!shrinkActive && lastShrinkTime && now - lastShrinkTime > shrinkCooldown) shrinkReady = true;
    if (shrinkActive) {
      rechargeProgress = 0;
    } else if (!shrinkReady) {
      rechargeProgress = (now - lastShrinkTime) / shrinkCooldown;
      if (rechargeProgress >= 1) { rechargeProgress = 1; shrinkReady = true; }
    } else rechargeProgress = 1;
  } else if (player.type === 'purple') {
    if (!slowmoActive && lastSlowmoTime && now - lastSlowmoTime > slowmoCooldown) slowmoReady = true;
    if (slowmoActive) {
      rechargeProgress = 0;
    } else if (!slowmoReady) {
      rechargeProgress = (now - lastSlowmoTime) / slowmoCooldown;
      if (rechargeProgress >= 1) { rechargeProgress = 1; slowmoReady = true; }
    } else rechargeProgress = 1;
  } else if (player.type === 'orange') {
    if (!agilityActive && lastAgilityTime && now - lastAgilityTime > agilityCooldown) agilityReady = true;
    if (agilityActive) {
      rechargeProgress = 0;
    } else if (!agilityReady) {
      rechargeProgress = (now - lastAgilityTime) / agilityCooldown;
      if (rechargeProgress >= 1) { rechargeProgress = 1; agilityReady = true; }
    } else rechargeProgress = 1;
  } else if (player.type === 'cyan') {
    if (!magnetActive && lastMagnetTime && now - lastMagnetTime > magnetCooldown) magnetReady = true;
    if (magnetActive) {
      rechargeProgress = 0;
    } else if (!magnetReady) {
      rechargeProgress = (now - lastMagnetTime) / magnetCooldown;
      if (rechargeProgress >= 1) { rechargeProgress = 1; magnetReady = true; }
    } else rechargeProgress = 1;
  } else {
    rechargeProgress = 1;
  }

  // Mise √† jour de la barre de recharge : largeur en pourcentage
  document.getElementById('rechargeBarFilled').style.width = (rechargeProgress * 100) + "%";

  // Joueur
  let effectiveGravity = gravity;
  if (slowmoActive) {
    effectiveGravity *= slowmoMultiplier; // r√©duit la gravit√©
  } else if (player.type === 'orange' && agilityActive) {
    effectiveGravity *= (agilityVelocityBoost * agilityVelocityBoost); // augmente la gravit√© au carr√© pour garder la hauteur identique
  }
  player.y += player.velocityY;
  player.velocityY += effectiveGravity;

  if (player.y >= 220) {
    player.y = 220;
    player.velocityY = 0;
    player.jumping = false;
    // Le joueur a atterri : terminer la p√©riode d'invincibilit√© post-vol
    if (flyFalling) flyFalling = false;
  }
  // Effets de vol si actif (vert)
  if (player.type === 'green' && flyActive) {
    // Soulever l√©g√®rement le joueur et neutraliser la gravit√© temporairement
    player.y = Math.max(50, player.y - 2);
    player.velocityY = 0;
  }

  // Couleur et indication du joueur selon le type et l'√©tat
  if (player.type === 'red') {
    ctx.fillStyle = "red";
  } else if (player.type === 'blue') {
    // Le cube bleu est toujours bleu
    ctx.fillStyle = "blue";
  } else if (player.type === 'green') {
    // Le cube vert reste vert m√™me pendant le vol
    ctx.fillStyle = "green";
  } else if (player.type === 'yellow') {
    // Le cube jaune devient plus √©clatant si le multiplicateur est actif
    ctx.fillStyle = scoreMultiplierActive ? "yellow" : "gold";
  } else if (player.type === 'purple') {
    // Le cube violet devient plus lumineux si ralentissement actif
    ctx.fillStyle = slowmoActive ? "#5300A1" : "#5300A1";
  } else if (player.type === 'cyan') {
    // Le cube cyan brille si aimant actif
    ctx.fillStyle = magnetActive ? "#00E5FF" : "cyan";
  } else if (player.type === 'orange') {
    // Le cube orange brille si agilit√© active
    ctx.fillStyle = agilityActive ? "#FF6500" : "#FF9500";
    } else if (player.type === 'gray') {
      // Le cube gris indique son √©tat quand la r√©duction est active
      ctx.fillStyle = shrinkActive ? "#A9A9A9" : "gray";
  } else {
    ctx.fillStyle = "white"; // par d√©faut
  }
  ctx.fillRect(player.x, player.y, player.width, player.height);

  // Indicateur pr√™t selon le type
  if (player.type === 'blue' && shieldReady && !shieldActive) {
    ctx.fillStyle = "yellow"; ctx.font = "12px Arial"; ctx.fillText("‚ö° READY", player.x - 10, player.y - 10);
    ctx.strokeStyle = "yellow"; ctx.lineWidth = 2; ctx.strokeRect(player.x - 5, player.y - 5, player.width + 10, player.height + 10);
  } else if (player.type === 'green' && flyReady && !flyActive) {
    ctx.fillStyle = "yellow"; ctx.font = "12px Arial"; ctx.fillText("üïä READY", player.x - 12, player.y - 10);
    ctx.strokeStyle = "yellow"; ctx.lineWidth = 2; ctx.strokeRect(player.x - 5, player.y - 5, player.width + 10, player.height + 10);
  } else if (player.type === 'red') {
    // Indiquer si le tir est pr√™t
    if (rechargeProgress >= 1) {
      ctx.fillStyle = "yellow"; ctx.font = "12px Arial"; ctx.fillText("üî´ READY", player.x - 12, player.y - 10);
      ctx.strokeStyle = "yellow"; ctx.lineWidth = 2; ctx.strokeRect(player.x - 5, player.y - 5, player.width + 10, player.height + 10);
    }
  } else if (player.type === 'yellow' && scoreMultiplierReady && !scoreMultiplierActive) {
    ctx.fillStyle = "white"; ctx.font = "12px Arial"; ctx.fillText("‚ö°x3 READY", player.x - 20, player.y - 10);
    ctx.strokeStyle = "white"; ctx.lineWidth = 2; ctx.strokeRect(player.x - 5, player.y - 5, player.width + 10, player.height + 10);
  } else if (player.type === 'purple' && slowmoReady && !slowmoActive) {
    ctx.fillStyle = "mediumpurple"; ctx.font = "12px Arial"; ctx.fillText("‚è± READY", player.x - 12, player.y - 10);
    ctx.strokeStyle = "mediumpurple"; ctx.lineWidth = 2; ctx.strokeRect(player.x - 5, player.y - 5, player.width + 10, player.height + 10);
  } else if (player.type === 'orange' && agilityReady && !agilityActive) {
    ctx.fillStyle = "orange"; ctx.font = "12px Arial"; ctx.fillText("‚ö° READY", player.x - 12, player.y - 10);
    ctx.strokeStyle = "orange"; ctx.lineWidth = 2; ctx.strokeRect(player.x - 5, player.y - 5, player.width + 10, player.height + 10);
  } else if (player.type === 'cyan' && magnetReady && !magnetActive) {
    ctx.fillStyle = "cyan"; ctx.font = "12px Arial"; ctx.fillText("üß≤ READY", player.x - 12, player.y - 10);
    ctx.strokeStyle = "cyan"; ctx.lineWidth = 2; ctx.strokeRect(player.x - 5, player.y - 5, player.width + 10, player.height + 10);
  } else if (player.type === 'gray' && shrinkReady && !shrinkActive) {
    ctx.fillStyle = "gray"; ctx.font = "12px Arial"; ctx.fillText("‚á≥ SMALL", player.x - 18, player.y - 10);
    ctx.strokeStyle = "gray"; ctx.lineWidth = 1; ctx.strokeRect(player.x - 5, player.y - 5, player.width + 10, player.height + 10);
  }

  
  // Obstacles
  // Dessiner et g√©rer collisions (si bouclier actif, aucune perte)
  obstacles.forEach((obs, index) => {
    let effectiveSpeed = obs.speed * (slowmoActive ? slowmoMultiplier : 1);
    
    // Aimant : attirer les obstacles vers le joueur
    if (player.type === 'cyan' && magnetActive) {
      const dx = player.x + player.width / 2 - (obs.x + obs.width / 2);
      const dy = player.y + player.height / 2 - (obs.y + obs.height / 2);
      const distance = Math.sqrt(dx * dx + dy * dy);
      if (distance > 0) {
        const magnetStrength = 8;
        obs.x += (dx / distance) * magnetStrength;
        obs.y += (dy / distance) * magnetStrength;
      }
    } else {
      obs.x += effectiveSpeed;
    }
    
    // Couleur des obstacles : orange si agilit√© active (orange),
    // cyan si aimant actif (cyan), bleu si bouclier actif (bleu), sinon blanc
      // Determine drawn size when shrink is active
      const drawW = shrinkActive ? obs.width * shrinkFactor : obs.width;
      const drawH = shrinkActive ? obs.height * shrinkFactor : obs.height;
      const drawX = obs.x + (obs.width - drawW) / 2;
      const drawY = obs.y + (obs.height - drawH) / 2;

      if (player.type === 'orange' && agilityActive) {
        ctx.fillStyle = "orange";
      } else if (player.type === 'cyan' && magnetActive) {
        ctx.fillStyle = "cyan";
      } else {
        ctx.fillStyle = (player.type === 'blue' && shieldActive) ? "blue" : "white";
      }
      ctx.fillRect(drawX, drawY, drawW, drawH);

    // Nettoyage hors-√©cran (garder ce check m√™me si le joueur est en vol)
    if (obs.x < -50 || obs.x > canvas.width + 50) {
      obstacles.splice(index, 1);
      return;
    }

    // Si le joueur est le cube vert en vol ou en descente post-vol, il est invincible :
    // on ignore les collisions (les obstacles passent sous le joueur).
    if (player.type === 'green' && (flyActive || flyFalling)) {
      return; // continue
    }

    // Collision (trait√©e normalement pour les autres cas)
    if (
      player.x < drawX + drawW &&
      player.x + player.width > drawX &&
      player.y < drawY + drawH &&
      player.y + player.height > drawY
    ) {
      if (player.type === 'blue' && shieldActive) {
        // neutralis√© par le bouclier
        scores['blue'] += 100; // Ajouter 100 points au score
        obstacles.splice(index, 1);
      } else if (player.type === 'cyan' && magnetActive) {
        // neutralis√© par l'aimant
        scores['cyan'] += 100; // Ajouter 100 points au score
        obstacles.splice(index, 1);
      } else if (player.type === 'red') {
        // collision normale (si red n'a pas de bouclier) -> game over
        gameOver = true; gameOverScreen();
      } else {
        gameOver = true; gameOverScreen();
      }
    }
  });

  requestAnimationFrame(update);
}

// Afficher les meilleurs niveaux au d√©marrage
updateBestLevelsDisplay();

update();
</script>

</body>
</html>

